{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rectangleCollidesWithQuad = exports.squareCollidesWithQuad = exports.getCircumscribedAlignedRectangle = exports.isRectangleAligned = void 0;\n/**\n * Sigma.js Quad Tree Class\n * =========================\n *\n * Class implementing the quad tree data structure used to solve hovers and\n * determine which elements are currently in the scope of the camera so that\n * we don't waste time rendering things the user cannot see anyway.\n * @module\n */\n/* eslint no-nested-ternary: 0 */\n/* eslint no-constant-condition: 0 */\nvar extend_1 = __importDefault(require(\"@yomguithereal/helpers/extend\"));\n// TODO: should not ask the quadtree when the camera has the whole graph in\n// sight.\n// TODO: a square can be represented as topleft + width, saying for the quad blocks (reduce mem)\n// TODO: jsdoc\n// TODO: be sure we can handle cases overcoming boundaries (because of size) or use a maxed size\n// TODO: filtering unwanted labels beforehand through the filter function\n// NOTE: this is basically a MX-CIF Quadtree at this point\n// NOTE: need to explore R-Trees for edges\n// NOTE: need to explore 2d segment tree for edges\n// NOTE: probably can do faster using spatial hashing\n/**\n * Constants.\n *\n * Note that since we are representing a static 4-ary tree, the indices of the\n * quadrants are the following:\n *   - TOP_LEFT:     4i + b\n *   - TOP_RIGHT:    4i + 2b\n *   - BOTTOM_LEFT:  4i + 3b\n *   - BOTTOM_RIGHT: 4i + 4b\n */\nvar BLOCKS = 4,\n  MAX_LEVEL = 5;\nvar OUTSIDE_BLOCK = \"outside\";\nvar X_OFFSET = 0,\n  Y_OFFSET = 1,\n  WIDTH_OFFSET = 2,\n  HEIGHT_OFFSET = 3;\nvar TOP_LEFT = 1,\n  TOP_RIGHT = 2,\n  BOTTOM_LEFT = 3,\n  BOTTOM_RIGHT = 4;\nvar hasWarnedTooMuchOutside = false;\n/**\n * Geometry helpers.\n */\n/**\n * Function returning whether the given rectangle is axis-aligned.\n *\n * @param  {Rectangle} rect\n * @return {boolean}\n */\nfunction isRectangleAligned(rect) {\n  return rect.x1 === rect.x2 || rect.y1 === rect.y2;\n}\nexports.isRectangleAligned = isRectangleAligned;\n/**\n * Function returning the smallest rectangle that contains the given rectangle, and that is aligned with the axis.\n *\n * @param {Rectangle} rect\n * @return {Rectangle}\n */\nfunction getCircumscribedAlignedRectangle(rect) {\n  var width = Math.sqrt(Math.pow(rect.x2 - rect.x1, 2) + Math.pow(rect.y2 - rect.y1, 2));\n  var heightVector = {\n    x: (rect.y1 - rect.y2) * rect.height / width,\n    y: (rect.x2 - rect.x1) * rect.height / width\n  };\n  // Compute all corners:\n  var tl = {\n    x: rect.x1,\n    y: rect.y1\n  };\n  var tr = {\n    x: rect.x2,\n    y: rect.y2\n  };\n  var bl = {\n    x: rect.x1 + heightVector.x,\n    y: rect.y1 + heightVector.y\n  };\n  var br = {\n    x: rect.x2 + heightVector.x,\n    y: rect.y2 + heightVector.y\n  };\n  var xL = Math.min(tl.x, tr.x, bl.x, br.x);\n  var xR = Math.max(tl.x, tr.x, bl.x, br.x);\n  var yT = Math.min(tl.y, tr.y, bl.y, br.y);\n  var yB = Math.max(tl.y, tr.y, bl.y, br.y);\n  return {\n    x1: xL,\n    y1: yT,\n    x2: xR,\n    y2: yT,\n    height: yB - yT\n  };\n}\nexports.getCircumscribedAlignedRectangle = getCircumscribedAlignedRectangle;\n/**\n *\n * @param x1\n * @param y1\n * @param w\n * @param qx\n * @param qy\n * @param qw\n * @param qh\n */\nfunction squareCollidesWithQuad(x1, y1, w, qx, qy, qw, qh) {\n  return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + w > qy;\n}\nexports.squareCollidesWithQuad = squareCollidesWithQuad;\nfunction rectangleCollidesWithQuad(x1, y1, w, h, qx, qy, qw, qh) {\n  return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + h > qy;\n}\nexports.rectangleCollidesWithQuad = rectangleCollidesWithQuad;\nfunction pointIsInQuad(x, y, qx, qy, qw, qh) {\n  var xmp = qx + qw / 2,\n    ymp = qy + qh / 2,\n    top = y < ymp,\n    left = x < xmp;\n  return top ? left ? TOP_LEFT : TOP_RIGHT : left ? BOTTOM_LEFT : BOTTOM_RIGHT;\n}\n/**\n * Helper functions that are not bound to the class so an external user\n * cannot mess with them.\n */\nfunction buildQuadrants(maxLevel, data) {\n  // [block, level]\n  var stack = [0, 0];\n  while (stack.length) {\n    var level = stack.pop(),\n      block = stack.pop();\n    var topLeftBlock = 4 * block + BLOCKS,\n      topRightBlock = 4 * block + 2 * BLOCKS,\n      bottomLeftBlock = 4 * block + 3 * BLOCKS,\n      bottomRightBlock = 4 * block + 4 * BLOCKS;\n    var x = data[block + X_OFFSET],\n      y = data[block + Y_OFFSET],\n      width = data[block + WIDTH_OFFSET],\n      height = data[block + HEIGHT_OFFSET],\n      hw = width / 2,\n      hh = height / 2;\n    data[topLeftBlock + X_OFFSET] = x;\n    data[topLeftBlock + Y_OFFSET] = y;\n    data[topLeftBlock + WIDTH_OFFSET] = hw;\n    data[topLeftBlock + HEIGHT_OFFSET] = hh;\n    data[topRightBlock + X_OFFSET] = x + hw;\n    data[topRightBlock + Y_OFFSET] = y;\n    data[topRightBlock + WIDTH_OFFSET] = hw;\n    data[topRightBlock + HEIGHT_OFFSET] = hh;\n    data[bottomLeftBlock + X_OFFSET] = x;\n    data[bottomLeftBlock + Y_OFFSET] = y + hh;\n    data[bottomLeftBlock + WIDTH_OFFSET] = hw;\n    data[bottomLeftBlock + HEIGHT_OFFSET] = hh;\n    data[bottomRightBlock + X_OFFSET] = x + hw;\n    data[bottomRightBlock + Y_OFFSET] = y + hh;\n    data[bottomRightBlock + WIDTH_OFFSET] = hw;\n    data[bottomRightBlock + HEIGHT_OFFSET] = hh;\n    if (level < maxLevel - 1) {\n      stack.push(bottomRightBlock, level + 1);\n      stack.push(bottomLeftBlock, level + 1);\n      stack.push(topRightBlock, level + 1);\n      stack.push(topLeftBlock, level + 1);\n    }\n  }\n}\nfunction insertNode(maxLevel, data, containers, key, x, y, size) {\n  var x1 = x - size,\n    y1 = y - size,\n    w = size * 2;\n  var level = 0,\n    block = 0;\n  while (true) {\n    // If we reached max level\n    if (level >= maxLevel) {\n      containers[block] = containers[block] || [];\n      containers[block].push(key);\n      return;\n    }\n    var topLeftBlock = 4 * block + BLOCKS,\n      topRightBlock = 4 * block + 2 * BLOCKS,\n      bottomLeftBlock = 4 * block + 3 * BLOCKS,\n      bottomRightBlock = 4 * block + 4 * BLOCKS;\n    var collidingWithTopLeft = squareCollidesWithQuad(x1, y1, w, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithTopRight = squareCollidesWithQuad(x1, y1, w, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomLeft = squareCollidesWithQuad(x1, y1, w, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomRight = squareCollidesWithQuad(x1, y1, w, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);\n    var collisions = [collidingWithTopLeft, collidingWithTopRight, collidingWithBottomLeft, collidingWithBottomRight].reduce(function (acc, current) {\n      if (current) return acc + 1;else return acc;\n    }, 0);\n    // If we have no collision at root level, inject node in the outside block\n    if (collisions === 0 && level === 0) {\n      containers[OUTSIDE_BLOCK].push(key);\n      if (!hasWarnedTooMuchOutside && containers[OUTSIDE_BLOCK].length >= 5) {\n        hasWarnedTooMuchOutside = true;\n        console.warn(\"sigma/quadtree.insertNode: At least 5 nodes are outside the global quadtree zone. \" + \"You might have a problem with the normalization function or the custom bounding box.\");\n      }\n      return;\n    }\n    // If we don't have at least a collision but deeper, there is an issue\n    if (collisions === 0) throw new Error(\"sigma/quadtree.insertNode: no collision (level: \".concat(level, \", key: \").concat(key, \", x: \").concat(x, \", y: \").concat(y, \", size: \").concat(size, \").\"));\n    // If we have 3 collisions, we have a geometry problem obviously\n    if (collisions === 3) throw new Error(\"sigma/quadtree.insertNode: 3 impossible collisions (level: \".concat(level, \", key: \").concat(key, \", x: \").concat(x, \", y: \").concat(y, \", size: \").concat(size, \").\"));\n    // If we have more that one collision, we stop here and store the node\n    // in the relevant containers\n    if (collisions > 1) {\n      containers[block] = containers[block] || [];\n      containers[block].push(key);\n      return;\n    } else {\n      level++;\n    }\n    // Else we recurse into the correct quads\n    if (collidingWithTopLeft) block = topLeftBlock;\n    if (collidingWithTopRight) block = topRightBlock;\n    if (collidingWithBottomLeft) block = bottomLeftBlock;\n    if (collidingWithBottomRight) block = bottomRightBlock;\n  }\n}\nfunction getNodesInAxisAlignedRectangleArea(maxLevel, data, containers, x1, y1, w, h) {\n  // [block, level]\n  var stack = [0, 0];\n  var collectedNodes = [];\n  var container;\n  while (stack.length) {\n    var level = stack.pop(),\n      block = stack.pop();\n    // Collecting nodes\n    container = containers[block];\n    if (container) (0, extend_1.default)(collectedNodes, container);\n    // If we reached max level\n    if (level >= maxLevel) continue;\n    var topLeftBlock = 4 * block + BLOCKS,\n      topRightBlock = 4 * block + 2 * BLOCKS,\n      bottomLeftBlock = 4 * block + 3 * BLOCKS,\n      bottomRightBlock = 4 * block + 4 * BLOCKS;\n    var collidingWithTopLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithTopRight = rectangleCollidesWithQuad(x1, y1, w, h, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomRight = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);\n    if (collidingWithTopLeft) stack.push(topLeftBlock, level + 1);\n    if (collidingWithTopRight) stack.push(topRightBlock, level + 1);\n    if (collidingWithBottomLeft) stack.push(bottomLeftBlock, level + 1);\n    if (collidingWithBottomRight) stack.push(bottomRightBlock, level + 1);\n  }\n  return collectedNodes;\n}\n/**\n * QuadTree class.\n *\n * @constructor\n * @param {object} boundaries - The graph boundaries.\n */\nvar QuadTree = /** @class */function () {\n  function QuadTree(params) {\n    var _a;\n    if (params === void 0) {\n      params = {};\n    }\n    this.containers = (_a = {}, _a[OUTSIDE_BLOCK] = [], _a);\n    this.cache = null;\n    this.lastRectangle = null;\n    // Allocating the underlying byte array\n    var L = Math.pow(4, MAX_LEVEL);\n    this.data = new Float32Array(BLOCKS * ((4 * L - 1) / 3));\n    if (params.boundaries) this.resize(params.boundaries);else this.resize({\n      x: 0,\n      y: 0,\n      width: 1,\n      height: 1\n    });\n  }\n  QuadTree.prototype.add = function (key, x, y, size) {\n    insertNode(MAX_LEVEL, this.data, this.containers, key, x, y, size);\n    return this;\n  };\n  QuadTree.prototype.resize = function (boundaries) {\n    this.clear();\n    // Building the quadrants\n    this.data[X_OFFSET] = boundaries.x;\n    this.data[Y_OFFSET] = boundaries.y;\n    this.data[WIDTH_OFFSET] = boundaries.width;\n    this.data[HEIGHT_OFFSET] = boundaries.height;\n    buildQuadrants(MAX_LEVEL, this.data);\n  };\n  QuadTree.prototype.clear = function () {\n    var _a;\n    this.containers = (_a = {}, _a[OUTSIDE_BLOCK] = [], _a);\n    return this;\n  };\n  QuadTree.prototype.point = function (x, y) {\n    var nodes = this.containers[OUTSIDE_BLOCK];\n    var block = 0,\n      level = 0;\n    do {\n      if (this.containers[block]) nodes.push.apply(nodes, __spreadArray([], __read(this.containers[block]), false));\n      var quad = pointIsInQuad(x, y, this.data[block + X_OFFSET], this.data[block + Y_OFFSET], this.data[block + WIDTH_OFFSET], this.data[block + HEIGHT_OFFSET]);\n      block = 4 * block + quad * BLOCKS;\n      level++;\n    } while (level <= MAX_LEVEL);\n    return nodes;\n  };\n  QuadTree.prototype.rectangle = function (x1, y1, x2, y2, height) {\n    var _a;\n    var lr = this.lastRectangle;\n    if (lr && x1 === lr.x1 && x2 === lr.x2 && y1 === lr.y1 && y2 === lr.y2 && height === lr.height) {\n      return this.cache;\n    }\n    this.lastRectangle = {\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      height: height\n    };\n    // If the rectangle is shifted, we use the smallest aligned rectangle that contains the shifted one:\n    if (!isRectangleAligned(this.lastRectangle)) this.lastRectangle = getCircumscribedAlignedRectangle(this.lastRectangle);\n    this.cache = getNodesInAxisAlignedRectangleArea(MAX_LEVEL, this.data, this.containers, x1, y1, Math.abs(x1 - x2) || Math.abs(y1 - y2), height);\n    // Add all the nodes in the outside block, since they might be relevant, and since they should be very few:\n    (_a = this.cache).push.apply(_a, __spreadArray([], __read(this.containers[OUTSIDE_BLOCK]), false));\n    return this.cache;\n  };\n  return QuadTree;\n}();\nexports.default = QuadTree;","map":{"version":3,"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","__spreadArray","to","from","pack","arguments","length","l","Array","prototype","slice","concat","__importDefault","mod","__esModule","Object","defineProperty","exports","rectangleCollidesWithQuad","squareCollidesWithQuad","getCircumscribedAlignedRectangle","isRectangleAligned","extend_1","require","BLOCKS","MAX_LEVEL","OUTSIDE_BLOCK","X_OFFSET","Y_OFFSET","WIDTH_OFFSET","HEIGHT_OFFSET","TOP_LEFT","TOP_RIGHT","BOTTOM_LEFT","BOTTOM_RIGHT","hasWarnedTooMuchOutside","rect","x1","x2","y1","y2","width","Math","sqrt","pow","heightVector","x","height","y","tl","tr","bl","br","xL","min","xR","max","yT","yB","w","qx","qy","qw","qh","h","pointIsInQuad","xmp","ymp","top","left","buildQuadrants","maxLevel","data","stack","level","pop","block","topLeftBlock","topRightBlock","bottomLeftBlock","bottomRightBlock","hw","hh","insertNode","containers","key","size","collidingWithTopLeft","collidingWithTopRight","collidingWithBottomLeft","collidingWithBottomRight","collisions","reduce","acc","current","console","warn","Error","getNodesInAxisAlignedRectangleArea","collectedNodes","container","default","QuadTree","params","_a","cache","lastRectangle","L","Float32Array","boundaries","resize","add","clear","point","nodes","apply","quad","rectangle","lr","abs"],"sources":["/Users/declanbradley/Documents/GitHub/house-finance/node_modules/sigma/core/quadtree.js"],"sourcesContent":["\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rectangleCollidesWithQuad = exports.squareCollidesWithQuad = exports.getCircumscribedAlignedRectangle = exports.isRectangleAligned = void 0;\n/**\n * Sigma.js Quad Tree Class\n * =========================\n *\n * Class implementing the quad tree data structure used to solve hovers and\n * determine which elements are currently in the scope of the camera so that\n * we don't waste time rendering things the user cannot see anyway.\n * @module\n */\n/* eslint no-nested-ternary: 0 */\n/* eslint no-constant-condition: 0 */\nvar extend_1 = __importDefault(require(\"@yomguithereal/helpers/extend\"));\n// TODO: should not ask the quadtree when the camera has the whole graph in\n// sight.\n// TODO: a square can be represented as topleft + width, saying for the quad blocks (reduce mem)\n// TODO: jsdoc\n// TODO: be sure we can handle cases overcoming boundaries (because of size) or use a maxed size\n// TODO: filtering unwanted labels beforehand through the filter function\n// NOTE: this is basically a MX-CIF Quadtree at this point\n// NOTE: need to explore R-Trees for edges\n// NOTE: need to explore 2d segment tree for edges\n// NOTE: probably can do faster using spatial hashing\n/**\n * Constants.\n *\n * Note that since we are representing a static 4-ary tree, the indices of the\n * quadrants are the following:\n *   - TOP_LEFT:     4i + b\n *   - TOP_RIGHT:    4i + 2b\n *   - BOTTOM_LEFT:  4i + 3b\n *   - BOTTOM_RIGHT: 4i + 4b\n */\nvar BLOCKS = 4, MAX_LEVEL = 5;\nvar OUTSIDE_BLOCK = \"outside\";\nvar X_OFFSET = 0, Y_OFFSET = 1, WIDTH_OFFSET = 2, HEIGHT_OFFSET = 3;\nvar TOP_LEFT = 1, TOP_RIGHT = 2, BOTTOM_LEFT = 3, BOTTOM_RIGHT = 4;\nvar hasWarnedTooMuchOutside = false;\n/**\n * Geometry helpers.\n */\n/**\n * Function returning whether the given rectangle is axis-aligned.\n *\n * @param  {Rectangle} rect\n * @return {boolean}\n */\nfunction isRectangleAligned(rect) {\n    return rect.x1 === rect.x2 || rect.y1 === rect.y2;\n}\nexports.isRectangleAligned = isRectangleAligned;\n/**\n * Function returning the smallest rectangle that contains the given rectangle, and that is aligned with the axis.\n *\n * @param {Rectangle} rect\n * @return {Rectangle}\n */\nfunction getCircumscribedAlignedRectangle(rect) {\n    var width = Math.sqrt(Math.pow(rect.x2 - rect.x1, 2) + Math.pow(rect.y2 - rect.y1, 2));\n    var heightVector = {\n        x: ((rect.y1 - rect.y2) * rect.height) / width,\n        y: ((rect.x2 - rect.x1) * rect.height) / width,\n    };\n    // Compute all corners:\n    var tl = { x: rect.x1, y: rect.y1 };\n    var tr = { x: rect.x2, y: rect.y2 };\n    var bl = {\n        x: rect.x1 + heightVector.x,\n        y: rect.y1 + heightVector.y,\n    };\n    var br = {\n        x: rect.x2 + heightVector.x,\n        y: rect.y2 + heightVector.y,\n    };\n    var xL = Math.min(tl.x, tr.x, bl.x, br.x);\n    var xR = Math.max(tl.x, tr.x, bl.x, br.x);\n    var yT = Math.min(tl.y, tr.y, bl.y, br.y);\n    var yB = Math.max(tl.y, tr.y, bl.y, br.y);\n    return {\n        x1: xL,\n        y1: yT,\n        x2: xR,\n        y2: yT,\n        height: yB - yT,\n    };\n}\nexports.getCircumscribedAlignedRectangle = getCircumscribedAlignedRectangle;\n/**\n *\n * @param x1\n * @param y1\n * @param w\n * @param qx\n * @param qy\n * @param qw\n * @param qh\n */\nfunction squareCollidesWithQuad(x1, y1, w, qx, qy, qw, qh) {\n    return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + w > qy;\n}\nexports.squareCollidesWithQuad = squareCollidesWithQuad;\nfunction rectangleCollidesWithQuad(x1, y1, w, h, qx, qy, qw, qh) {\n    return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + h > qy;\n}\nexports.rectangleCollidesWithQuad = rectangleCollidesWithQuad;\nfunction pointIsInQuad(x, y, qx, qy, qw, qh) {\n    var xmp = qx + qw / 2, ymp = qy + qh / 2, top = y < ymp, left = x < xmp;\n    return top ? (left ? TOP_LEFT : TOP_RIGHT) : left ? BOTTOM_LEFT : BOTTOM_RIGHT;\n}\n/**\n * Helper functions that are not bound to the class so an external user\n * cannot mess with them.\n */\nfunction buildQuadrants(maxLevel, data) {\n    // [block, level]\n    var stack = [0, 0];\n    while (stack.length) {\n        var level = stack.pop(), block = stack.pop();\n        var topLeftBlock = 4 * block + BLOCKS, topRightBlock = 4 * block + 2 * BLOCKS, bottomLeftBlock = 4 * block + 3 * BLOCKS, bottomRightBlock = 4 * block + 4 * BLOCKS;\n        var x = data[block + X_OFFSET], y = data[block + Y_OFFSET], width = data[block + WIDTH_OFFSET], height = data[block + HEIGHT_OFFSET], hw = width / 2, hh = height / 2;\n        data[topLeftBlock + X_OFFSET] = x;\n        data[topLeftBlock + Y_OFFSET] = y;\n        data[topLeftBlock + WIDTH_OFFSET] = hw;\n        data[topLeftBlock + HEIGHT_OFFSET] = hh;\n        data[topRightBlock + X_OFFSET] = x + hw;\n        data[topRightBlock + Y_OFFSET] = y;\n        data[topRightBlock + WIDTH_OFFSET] = hw;\n        data[topRightBlock + HEIGHT_OFFSET] = hh;\n        data[bottomLeftBlock + X_OFFSET] = x;\n        data[bottomLeftBlock + Y_OFFSET] = y + hh;\n        data[bottomLeftBlock + WIDTH_OFFSET] = hw;\n        data[bottomLeftBlock + HEIGHT_OFFSET] = hh;\n        data[bottomRightBlock + X_OFFSET] = x + hw;\n        data[bottomRightBlock + Y_OFFSET] = y + hh;\n        data[bottomRightBlock + WIDTH_OFFSET] = hw;\n        data[bottomRightBlock + HEIGHT_OFFSET] = hh;\n        if (level < maxLevel - 1) {\n            stack.push(bottomRightBlock, level + 1);\n            stack.push(bottomLeftBlock, level + 1);\n            stack.push(topRightBlock, level + 1);\n            stack.push(topLeftBlock, level + 1);\n        }\n    }\n}\nfunction insertNode(maxLevel, data, containers, key, x, y, size) {\n    var x1 = x - size, y1 = y - size, w = size * 2;\n    var level = 0, block = 0;\n    while (true) {\n        // If we reached max level\n        if (level >= maxLevel) {\n            containers[block] = containers[block] || [];\n            containers[block].push(key);\n            return;\n        }\n        var topLeftBlock = 4 * block + BLOCKS, topRightBlock = 4 * block + 2 * BLOCKS, bottomLeftBlock = 4 * block + 3 * BLOCKS, bottomRightBlock = 4 * block + 4 * BLOCKS;\n        var collidingWithTopLeft = squareCollidesWithQuad(x1, y1, w, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);\n        var collidingWithTopRight = squareCollidesWithQuad(x1, y1, w, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);\n        var collidingWithBottomLeft = squareCollidesWithQuad(x1, y1, w, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);\n        var collidingWithBottomRight = squareCollidesWithQuad(x1, y1, w, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);\n        var collisions = [\n            collidingWithTopLeft,\n            collidingWithTopRight,\n            collidingWithBottomLeft,\n            collidingWithBottomRight,\n        ].reduce(function (acc, current) {\n            if (current)\n                return acc + 1;\n            else\n                return acc;\n        }, 0);\n        // If we have no collision at root level, inject node in the outside block\n        if (collisions === 0 && level === 0) {\n            containers[OUTSIDE_BLOCK].push(key);\n            if (!hasWarnedTooMuchOutside && containers[OUTSIDE_BLOCK].length >= 5) {\n                hasWarnedTooMuchOutside = true;\n                console.warn(\"sigma/quadtree.insertNode: At least 5 nodes are outside the global quadtree zone. \" +\n                    \"You might have a problem with the normalization function or the custom bounding box.\");\n            }\n            return;\n        }\n        // If we don't have at least a collision but deeper, there is an issue\n        if (collisions === 0)\n            throw new Error(\"sigma/quadtree.insertNode: no collision (level: \".concat(level, \", key: \").concat(key, \", x: \").concat(x, \", y: \").concat(y, \", size: \").concat(size, \").\"));\n        // If we have 3 collisions, we have a geometry problem obviously\n        if (collisions === 3)\n            throw new Error(\"sigma/quadtree.insertNode: 3 impossible collisions (level: \".concat(level, \", key: \").concat(key, \", x: \").concat(x, \", y: \").concat(y, \", size: \").concat(size, \").\"));\n        // If we have more that one collision, we stop here and store the node\n        // in the relevant containers\n        if (collisions > 1) {\n            containers[block] = containers[block] || [];\n            containers[block].push(key);\n            return;\n        }\n        else {\n            level++;\n        }\n        // Else we recurse into the correct quads\n        if (collidingWithTopLeft)\n            block = topLeftBlock;\n        if (collidingWithTopRight)\n            block = topRightBlock;\n        if (collidingWithBottomLeft)\n            block = bottomLeftBlock;\n        if (collidingWithBottomRight)\n            block = bottomRightBlock;\n    }\n}\nfunction getNodesInAxisAlignedRectangleArea(maxLevel, data, containers, x1, y1, w, h) {\n    // [block, level]\n    var stack = [0, 0];\n    var collectedNodes = [];\n    var container;\n    while (stack.length) {\n        var level = stack.pop(), block = stack.pop();\n        // Collecting nodes\n        container = containers[block];\n        if (container)\n            (0, extend_1.default)(collectedNodes, container);\n        // If we reached max level\n        if (level >= maxLevel)\n            continue;\n        var topLeftBlock = 4 * block + BLOCKS, topRightBlock = 4 * block + 2 * BLOCKS, bottomLeftBlock = 4 * block + 3 * BLOCKS, bottomRightBlock = 4 * block + 4 * BLOCKS;\n        var collidingWithTopLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);\n        var collidingWithTopRight = rectangleCollidesWithQuad(x1, y1, w, h, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);\n        var collidingWithBottomLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);\n        var collidingWithBottomRight = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);\n        if (collidingWithTopLeft)\n            stack.push(topLeftBlock, level + 1);\n        if (collidingWithTopRight)\n            stack.push(topRightBlock, level + 1);\n        if (collidingWithBottomLeft)\n            stack.push(bottomLeftBlock, level + 1);\n        if (collidingWithBottomRight)\n            stack.push(bottomRightBlock, level + 1);\n    }\n    return collectedNodes;\n}\n/**\n * QuadTree class.\n *\n * @constructor\n * @param {object} boundaries - The graph boundaries.\n */\nvar QuadTree = /** @class */ (function () {\n    function QuadTree(params) {\n        var _a;\n        if (params === void 0) { params = {}; }\n        this.containers = (_a = {}, _a[OUTSIDE_BLOCK] = [], _a);\n        this.cache = null;\n        this.lastRectangle = null;\n        // Allocating the underlying byte array\n        var L = Math.pow(4, MAX_LEVEL);\n        this.data = new Float32Array(BLOCKS * ((4 * L - 1) / 3));\n        if (params.boundaries)\n            this.resize(params.boundaries);\n        else\n            this.resize({\n                x: 0,\n                y: 0,\n                width: 1,\n                height: 1,\n            });\n    }\n    QuadTree.prototype.add = function (key, x, y, size) {\n        insertNode(MAX_LEVEL, this.data, this.containers, key, x, y, size);\n        return this;\n    };\n    QuadTree.prototype.resize = function (boundaries) {\n        this.clear();\n        // Building the quadrants\n        this.data[X_OFFSET] = boundaries.x;\n        this.data[Y_OFFSET] = boundaries.y;\n        this.data[WIDTH_OFFSET] = boundaries.width;\n        this.data[HEIGHT_OFFSET] = boundaries.height;\n        buildQuadrants(MAX_LEVEL, this.data);\n    };\n    QuadTree.prototype.clear = function () {\n        var _a;\n        this.containers = (_a = {}, _a[OUTSIDE_BLOCK] = [], _a);\n        return this;\n    };\n    QuadTree.prototype.point = function (x, y) {\n        var nodes = this.containers[OUTSIDE_BLOCK];\n        var block = 0, level = 0;\n        do {\n            if (this.containers[block])\n                nodes.push.apply(nodes, __spreadArray([], __read(this.containers[block]), false));\n            var quad = pointIsInQuad(x, y, this.data[block + X_OFFSET], this.data[block + Y_OFFSET], this.data[block + WIDTH_OFFSET], this.data[block + HEIGHT_OFFSET]);\n            block = 4 * block + quad * BLOCKS;\n            level++;\n        } while (level <= MAX_LEVEL);\n        return nodes;\n    };\n    QuadTree.prototype.rectangle = function (x1, y1, x2, y2, height) {\n        var _a;\n        var lr = this.lastRectangle;\n        if (lr && x1 === lr.x1 && x2 === lr.x2 && y1 === lr.y1 && y2 === lr.y2 && height === lr.height) {\n            return this.cache;\n        }\n        this.lastRectangle = {\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2,\n            height: height,\n        };\n        // If the rectangle is shifted, we use the smallest aligned rectangle that contains the shifted one:\n        if (!isRectangleAligned(this.lastRectangle))\n            this.lastRectangle = getCircumscribedAlignedRectangle(this.lastRectangle);\n        this.cache = getNodesInAxisAlignedRectangleArea(MAX_LEVEL, this.data, this.containers, x1, y1, Math.abs(x1 - x2) || Math.abs(y1 - y2), height);\n        // Add all the nodes in the outside block, since they might be relevant, and since they should be very few:\n        (_a = this.cache).push.apply(_a, __spreadArray([], __read(this.containers[OUTSIDE_BLOCK]), false));\n        return this.cache;\n    };\n    return QuadTree;\n}());\nexports.default = QuadTree;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}