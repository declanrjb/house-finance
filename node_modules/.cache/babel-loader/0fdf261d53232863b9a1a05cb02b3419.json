{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar camera_1 = __importDefault(require(\"./core/camera\"));\nvar mouse_1 = __importDefault(require(\"./core/captors/mouse\"));\nvar quadtree_1 = __importDefault(require(\"./core/quadtree\"));\nvar types_1 = require(\"./types\");\nvar utils_1 = require(\"./utils\");\nvar labels_1 = require(\"./core/labels\");\nvar settings_1 = require(\"./settings\");\nvar touch_1 = __importDefault(require(\"./core/captors/touch\"));\nvar matrices_1 = require(\"./utils/matrices\");\nvar edge_collisions_1 = require(\"./utils/edge-collisions\");\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings, key, data) {\n  if (!data.hasOwnProperty(\"x\") || !data.hasOwnProperty(\"y\")) throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n  if (!data.color) data.color = settings.defaultNodeColor;\n  if (!data.label && data.label !== \"\") data.label = null;\n  if (data.label !== undefined && data.label !== null) data.label = \"\" + data.label;else data.label = null;\n  if (!data.size) data.size = 2;\n  if (!data.hasOwnProperty(\"hidden\")) data.hidden = false;\n  if (!data.hasOwnProperty(\"highlighted\")) data.highlighted = false;\n  if (!data.hasOwnProperty(\"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultNodeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\nfunction applyEdgeDefaults(settings, key, data) {\n  if (!data.color) data.color = settings.defaultEdgeColor;\n  if (!data.label) data.label = \"\";\n  if (!data.size) data.size = 0.5;\n  if (!data.hasOwnProperty(\"hidden\")) data.hidden = false;\n  if (!data.hasOwnProperty(\"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultEdgeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nvar Sigma = /** @class */function (_super) {\n  __extends(Sigma, _super);\n  function Sigma(graph, container, settings) {\n    if (settings === void 0) {\n      settings = {};\n    }\n    var _this = _super.call(this) || this;\n    _this.elements = {};\n    _this.canvasContexts = {};\n    _this.webGLContexts = {};\n    _this.activeListeners = {};\n    _this.quadtree = new quadtree_1.default();\n    _this.labelGrid = new labels_1.LabelGrid();\n    _this.nodeDataCache = {};\n    _this.edgeDataCache = {};\n    _this.nodesWithForcedLabels = [];\n    _this.edgesWithForcedLabels = [];\n    _this.nodeExtent = {\n      x: [0, 1],\n      y: [0, 1]\n    };\n    _this.matrix = (0, matrices_1.identity)();\n    _this.invMatrix = (0, matrices_1.identity)();\n    _this.correctionRatio = 1;\n    _this.customBBox = null;\n    _this.normalizationFunction = (0, utils_1.createNormalizationFunction)({\n      x: [0, 1],\n      y: [0, 1]\n    });\n    // Cache:\n    _this.cameraSizeRatio = 1;\n    // Starting dimensions and pixel ratio\n    _this.width = 0;\n    _this.height = 0;\n    _this.pixelRatio = (0, utils_1.getPixelRatio)();\n    // State\n    _this.displayedLabels = new Set();\n    _this.highlightedNodes = new Set();\n    _this.hoveredNode = null;\n    _this.hoveredEdge = null;\n    _this.renderFrame = null;\n    _this.renderHighlightedNodesFrame = null;\n    _this.needToProcess = false;\n    _this.needToSoftProcess = false;\n    _this.checkEdgesEventsFrame = null;\n    // Programs\n    _this.nodePrograms = {};\n    _this.hoverNodePrograms = {};\n    _this.edgePrograms = {};\n    _this.settings = (0, utils_1.assign)({}, settings_1.DEFAULT_SETTINGS, settings);\n    // Validating\n    (0, settings_1.validateSettings)(_this.settings);\n    (0, utils_1.validateGraph)(graph);\n    if (!(container instanceof HTMLElement)) throw new Error(\"Sigma: container should be an html element.\");\n    // Properties\n    _this.graph = graph;\n    _this.container = container;\n    // Initializing contexts\n    _this.createWebGLContext(\"edges\", {\n      preserveDrawingBuffer: true\n    });\n    _this.createCanvasContext(\"edgeLabels\");\n    _this.createWebGLContext(\"nodes\");\n    _this.createCanvasContext(\"labels\");\n    _this.createCanvasContext(\"hovers\");\n    _this.createWebGLContext(\"hoverNodes\");\n    _this.createCanvasContext(\"mouse\");\n    // Blending\n    for (var key in _this.webGLContexts) {\n      var gl = _this.webGLContexts[key];\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n      gl.enable(gl.BLEND);\n    }\n    // Loading programs\n    for (var type in _this.settings.nodeProgramClasses) {\n      var NodeProgramClass = _this.settings.nodeProgramClasses[type];\n      _this.nodePrograms[type] = new NodeProgramClass(_this.webGLContexts.nodes, _this);\n      _this.hoverNodePrograms[type] = new NodeProgramClass(_this.webGLContexts.hoverNodes, _this);\n    }\n    for (var type in _this.settings.edgeProgramClasses) {\n      var EdgeProgramClass = _this.settings.edgeProgramClasses[type];\n      _this.edgePrograms[type] = new EdgeProgramClass(_this.webGLContexts.edges, _this);\n    }\n    // Initial resize\n    _this.resize();\n    // Initializing the camera\n    _this.camera = new camera_1.default();\n    // Binding camera events\n    _this.bindCameraHandlers();\n    // Initializing captors\n    _this.mouseCaptor = new mouse_1.default(_this.elements.mouse, _this);\n    _this.touchCaptor = new touch_1.default(_this.elements.mouse, _this);\n    // Binding event handlers\n    _this.bindEventHandlers();\n    // Binding graph handlers\n    _this.bindGraphHandlers();\n    // Trigger eventual settings-related things\n    _this.handleSettingsUpdate();\n    // Processing data for the first time & render\n    _this.process();\n    _this.render();\n    return _this;\n  }\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n  /**\n   * Internal function used to create a canvas element.\n   * @param  {string} id - Context's id.\n   * @return {Sigma}\n   */\n  Sigma.prototype.createCanvas = function (id) {\n    var canvas = (0, utils_1.createElement)(\"canvas\", {\n      position: \"absolute\"\n    }, {\n      class: \"sigma-\".concat(id)\n    });\n    this.elements[id] = canvas;\n    this.container.appendChild(canvas);\n    return canvas;\n  };\n  /**\n   * Internal function used to create a canvas context and add the relevant\n   * DOM elements.\n   *\n   * @param  {string} id - Context's id.\n   * @return {Sigma}\n   */\n  Sigma.prototype.createCanvasContext = function (id) {\n    var canvas = this.createCanvas(id);\n    var contextOptions = {\n      preserveDrawingBuffer: false,\n      antialias: false\n    };\n    this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n    return this;\n  };\n  /**\n   * Internal function used to create a canvas context and add the relevant\n   * DOM elements.\n   *\n   * @param  {string}  id      - Context's id.\n   * @param  {object?} options - #getContext params to override (optional)\n   * @return {Sigma}\n   */\n  Sigma.prototype.createWebGLContext = function (id, options) {\n    var canvas = this.createCanvas(id);\n    var contextOptions = __assign({\n      preserveDrawingBuffer: false,\n      antialias: false\n    }, options || {});\n    var context;\n    // First we try webgl2 for an easy performance boost\n    context = canvas.getContext(\"webgl2\", contextOptions);\n    // Else we fall back to webgl\n    if (!context) context = canvas.getContext(\"webgl\", contextOptions);\n    // Edge, I am looking right at you...\n    if (!context) context = canvas.getContext(\"experimental-webgl\", contextOptions);\n    this.webGLContexts[id] = context;\n    return this;\n  };\n  /**\n   * Method binding camera handlers.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.bindCameraHandlers = function () {\n    var _this = this;\n    this.activeListeners.camera = function () {\n      _this._scheduleRefresh();\n    };\n    this.camera.on(\"updated\", this.activeListeners.camera);\n    return this;\n  };\n  /**\n   * Method that checks whether or not a node collides with a given position.\n   */\n  Sigma.prototype.mouseIsOnNode = function (_a, _b, size) {\n    var x = _a.x,\n      y = _a.y;\n    var nodeX = _b.x,\n      nodeY = _b.y;\n    return x > nodeX - size && x < nodeX + size && y > nodeY - size && y < nodeY + size && Math.sqrt(Math.pow(x - nodeX, 2) + Math.pow(y - nodeY, 2)) < size;\n  };\n  /**\n   * Method that returns all nodes in quad at a given position.\n   */\n  Sigma.prototype.getQuadNodes = function (position) {\n    var mouseGraphPosition = this.viewportToFramedGraph(position);\n    return this.quadtree.point(mouseGraphPosition.x, 1 - mouseGraphPosition.y);\n  };\n  /**\n   * Method that returns the closest node to a given position.\n   */\n  Sigma.prototype.getNodeAtPosition = function (position) {\n    var x = position.x,\n      y = position.y;\n    var quadNodes = this.getQuadNodes(position);\n    // We will hover the node whose center is closest to mouse\n    var minDistance = Infinity,\n      nodeAtPosition = null;\n    for (var i = 0, l = quadNodes.length; i < l; i++) {\n      var node = quadNodes[i];\n      var data = this.nodeDataCache[node];\n      var nodePosition = this.framedGraphToViewport(data);\n      var size = this.scaleSize(data.size);\n      if (!data.hidden && this.mouseIsOnNode(position, nodePosition, size)) {\n        var distance = Math.sqrt(Math.pow(x - nodePosition.x, 2) + Math.pow(y - nodePosition.y, 2));\n        // TODO: sort by min size also for cases where center is the same\n        if (distance < minDistance) {\n          minDistance = distance;\n          nodeAtPosition = node;\n        }\n      }\n    }\n    return nodeAtPosition;\n  };\n  /**\n   * Method binding event handlers.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.bindEventHandlers = function () {\n    var _this = this;\n    // Handling window resize\n    this.activeListeners.handleResize = function () {\n      _this.needToSoftProcess = true;\n      _this._scheduleRefresh();\n    };\n    window.addEventListener(\"resize\", this.activeListeners.handleResize);\n    // Handling mouse move\n    this.activeListeners.handleMove = function (e) {\n      var baseEvent = {\n        event: e,\n        preventSigmaDefault: function preventSigmaDefault() {\n          e.preventSigmaDefault();\n        }\n      };\n      var nodeToHover = _this.getNodeAtPosition(e);\n      if (nodeToHover && _this.hoveredNode !== nodeToHover && !_this.nodeDataCache[nodeToHover].hidden) {\n        // Handling passing from one node to the other directly\n        if (_this.hoveredNode) _this.emit(\"leaveNode\", __assign(__assign({}, baseEvent), {\n          node: _this.hoveredNode\n        }));\n        _this.hoveredNode = nodeToHover;\n        _this.emit(\"enterNode\", __assign(__assign({}, baseEvent), {\n          node: nodeToHover\n        }));\n        _this.scheduleHighlightedNodesRender();\n        return;\n      }\n      // Checking if the hovered node is still hovered\n      if (_this.hoveredNode) {\n        var data = _this.nodeDataCache[_this.hoveredNode];\n        var pos = _this.framedGraphToViewport(data);\n        var size = _this.scaleSize(data.size);\n        if (!_this.mouseIsOnNode(e, pos, size)) {\n          var node = _this.hoveredNode;\n          _this.hoveredNode = null;\n          _this.emit(\"leaveNode\", __assign(__assign({}, baseEvent), {\n            node: node\n          }));\n          _this.scheduleHighlightedNodesRender();\n          return;\n        }\n      }\n      if (_this.settings.enableEdgeHoverEvents === true) {\n        _this.checkEdgeHoverEvents(baseEvent);\n      } else if (_this.settings.enableEdgeHoverEvents === \"debounce\") {\n        if (!_this.checkEdgesEventsFrame) _this.checkEdgesEventsFrame = (0, utils_1.requestFrame)(function () {\n          _this.checkEdgeHoverEvents(baseEvent);\n          _this.checkEdgesEventsFrame = null;\n        });\n      }\n    };\n    // Handling click\n    var createMouseListener = function createMouseListener(eventType) {\n      return function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function preventSigmaDefault() {\n            e.preventSigmaDefault();\n          }\n        };\n        var isFakeSigmaMouseEvent = e.original.isFakeSigmaMouseEvent;\n        var nodeAtPosition = isFakeSigmaMouseEvent ? _this.getNodeAtPosition(e) : _this.hoveredNode;\n        if (nodeAtPosition) return _this.emit(\"\".concat(eventType, \"Node\"), __assign(__assign({}, baseEvent), {\n          node: nodeAtPosition\n        }));\n        if (eventType === \"wheel\" ? _this.settings.enableEdgeWheelEvents : _this.settings.enableEdgeClickEvents) {\n          var edge = _this.getEdgeAtPoint(e.x, e.y);\n          if (edge) return _this.emit(\"\".concat(eventType, \"Edge\"), __assign(__assign({}, baseEvent), {\n            edge: edge\n          }));\n        }\n        return _this.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n      };\n    };\n    this.activeListeners.handleClick = createMouseListener(\"click\");\n    this.activeListeners.handleRightClick = createMouseListener(\"rightClick\");\n    this.activeListeners.handleDoubleClick = createMouseListener(\"doubleClick\");\n    this.activeListeners.handleWheel = createMouseListener(\"wheel\");\n    this.activeListeners.handleDown = createMouseListener(\"down\");\n    this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n    this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n    this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n    this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n    this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n    this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n    // TODO\n    // Deal with Touch captor events\n    return this;\n  };\n  /**\n   * Method binding graph handlers\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.bindGraphHandlers = function () {\n    var _this = this;\n    var graph = this.graph;\n    this.activeListeners.graphUpdate = function () {\n      _this.needToProcess = true;\n      _this._scheduleRefresh();\n    };\n    this.activeListeners.softGraphUpdate = function () {\n      _this.needToSoftProcess = true;\n      _this._scheduleRefresh();\n    };\n    this.activeListeners.dropNodeGraphUpdate = function (e) {\n      delete _this.nodeDataCache[e.key];\n      if (_this.hoveredNode === e.key) _this.hoveredNode = null;\n      _this.activeListeners.graphUpdate();\n    };\n    this.activeListeners.dropEdgeGraphUpdate = function (e) {\n      delete _this.edgeDataCache[e.key];\n      if (_this.hoveredEdge === e.key) _this.hoveredEdge = null;\n      _this.activeListeners.graphUpdate();\n    };\n    this.activeListeners.clearEdgesGraphUpdate = function () {\n      _this.edgeDataCache = {};\n      _this.hoveredEdge = null;\n      _this.activeListeners.graphUpdate();\n    };\n    this.activeListeners.clearGraphUpdate = function () {\n      _this.nodeDataCache = {};\n      _this.hoveredNode = null;\n      _this.activeListeners.clearEdgesGraphUpdate();\n    };\n    graph.on(\"nodeAdded\", this.activeListeners.graphUpdate);\n    graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n    graph.on(\"nodeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n    graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.on(\"edgeAdded\", this.activeListeners.graphUpdate);\n    graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n    graph.on(\"edgeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n    graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n    graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n    return this;\n  };\n  /**\n   * Method dealing with \"leaveEdge\" and \"enterEdge\" events.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.checkEdgeHoverEvents = function (payload) {\n    var edgeToHover = this.hoveredNode ? null : this.getEdgeAtPoint(payload.event.x, payload.event.y);\n    if (edgeToHover !== this.hoveredEdge) {\n      if (this.hoveredEdge) this.emit(\"leaveEdge\", __assign(__assign({}, payload), {\n        edge: this.hoveredEdge\n      }));\n      if (edgeToHover) this.emit(\"enterEdge\", __assign(__assign({}, payload), {\n        edge: edgeToHover\n      }));\n      this.hoveredEdge = edgeToHover;\n    }\n    return this;\n  };\n  /**\n   * Method looking for an edge colliding with a given point at (x, y). Returns\n   * the key of the edge if any, or null else.\n   */\n  Sigma.prototype.getEdgeAtPoint = function (x, y) {\n    var e_1, _a;\n    var _this = this;\n    var _b = this,\n      edgeDataCache = _b.edgeDataCache,\n      nodeDataCache = _b.nodeDataCache;\n    // Check first that pixel is colored:\n    // Note that mouse positions must be corrected by pixel ratio to correctly\n    // index the drawing buffer.\n    if (!(0, edge_collisions_1.isPixelColored)(this.webGLContexts.edges, x * this.pixelRatio, y * this.pixelRatio)) return null;\n    // Check for each edge if it collides with the point:\n    var _c = this.viewportToGraph({\n        x: x,\n        y: y\n      }),\n      graphX = _c.x,\n      graphY = _c.y;\n    // To translate edge thicknesses to the graph system, we observe by how much\n    // the length of a non-null edge is transformed to between the graph system\n    // and the viewport system:\n    var transformationRatio = 0;\n    this.graph.someEdge(function (key, _, sourceId, targetId, _a, _b) {\n      var xs = _a.x,\n        ys = _a.y;\n      var xt = _b.x,\n        yt = _b.y;\n      if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden) return false;\n      if (xs !== xt || ys !== yt) {\n        var graphLength = Math.sqrt(Math.pow(xt - xs, 2) + Math.pow(yt - ys, 2));\n        var _c = _this.graphToViewport({\n            x: xs,\n            y: ys\n          }),\n          vp_xs = _c.x,\n          vp_ys = _c.y;\n        var _d = _this.graphToViewport({\n            x: xt,\n            y: yt\n          }),\n          vp_xt = _d.x,\n          vp_yt = _d.y;\n        var viewportLength = Math.sqrt(Math.pow(vp_xt - vp_xs, 2) + Math.pow(vp_yt - vp_ys, 2));\n        transformationRatio = graphLength / viewportLength;\n        return true;\n      }\n    });\n    // If no non-null edge has been found, return null:\n    if (!transformationRatio) return null;\n    // Now we can look for matching edges:\n    var edges = this.graph.filterEdges(function (key, edgeAttributes, sourceId, targetId, sourcePosition, targetPosition) {\n      if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden) return false;\n      if ((0, edge_collisions_1.doEdgeCollideWithPoint)(graphX, graphY, sourcePosition.x, sourcePosition.y, targetPosition.x, targetPosition.y,\n      // Adapt the edge size to the zoom ratio:\n      edgeDataCache[key].size * transformationRatio / _this.cameraSizeRatio)) {\n        return true;\n      }\n    });\n    if (edges.length === 0) return null; // no edges found\n    // if none of the edges have a zIndex, selected the most recently created one to match the rendering order\n    var selectedEdge = edges[edges.length - 1];\n    // otherwise select edge with highest zIndex\n    var highestZIndex = -Infinity;\n    try {\n      for (var edges_1 = __values(edges), edges_1_1 = edges_1.next(); !edges_1_1.done; edges_1_1 = edges_1.next()) {\n        var edge = edges_1_1.value;\n        var zIndex = this.graph.getEdgeAttribute(edge, \"zIndex\");\n        if (zIndex >= highestZIndex) {\n          selectedEdge = edge;\n          highestZIndex = zIndex;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (edges_1_1 && !edges_1_1.done && (_a = edges_1.return)) _a.call(edges_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return selectedEdge;\n  };\n  /**\n   * Method used to process the whole graph's data.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.process = function (keepArrays) {\n    var _this = this;\n    if (keepArrays === void 0) {\n      keepArrays = false;\n    }\n    var graph = this.graph;\n    var settings = this.settings;\n    var dimensions = this.getDimensions();\n    var nodeZExtent = [Infinity, -Infinity];\n    var edgeZExtent = [Infinity, -Infinity];\n    // Clearing the quad\n    this.quadtree.clear();\n    // Resetting the label grid\n    // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n    this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n    // Clear the highlightedNodes\n    this.highlightedNodes = new Set();\n    // Computing extents\n    this.nodeExtent = (0, utils_1.graphExtent)(graph);\n    // Resetting `forceLabel` indices\n    this.nodesWithForcedLabels = [];\n    this.edgesWithForcedLabels = [];\n    // NOTE: it is important to compute this matrix after computing the node's extent\n    // because #.getGraphDimensions relies on it\n    var nullCamera = new camera_1.default();\n    var nullCameraMatrix = (0, utils_1.matrixFromCamera)(nullCamera.getState(), this.getDimensions(), this.getGraphDimensions(), this.getSetting(\"stagePadding\") || 0);\n    // Rescaling function\n    this.normalizationFunction = (0, utils_1.createNormalizationFunction)(this.customBBox || this.nodeExtent);\n    var nodesPerPrograms = {};\n    var nodes = graph.nodes();\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      var node = nodes[i];\n      // Node display data resolution:\n      //   1. First we get the node's attributes\n      //   2. We optionally reduce them using the function provided by the user\n      //      Note that this function must return a total object and won't be merged\n      //   3. We apply our defaults, while running some vital checks\n      //   4. We apply the normalization function\n      // We shallow copy node data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, graph.getNodeAttributes(node));\n      if (settings.nodeReducer) attr = settings.nodeReducer(node, attr);\n      var data = applyNodeDefaults(this.settings, node, attr);\n      nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n      this.nodeDataCache[node] = data;\n      this.normalizationFunction.applyTo(data);\n      if (data.forceLabel) this.nodesWithForcedLabels.push(node);\n      if (this.settings.zIndex) {\n        if (data.zIndex < nodeZExtent[0]) nodeZExtent[0] = data.zIndex;\n        if (data.zIndex > nodeZExtent[1]) nodeZExtent[1] = data.zIndex;\n      }\n    }\n    for (var type in this.nodePrograms) {\n      if (!this.nodePrograms.hasOwnProperty(type)) {\n        throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n      }\n      if (!keepArrays) this.nodePrograms[type].allocate(nodesPerPrograms[type] || 0);\n      // We reset that count here, so that we can reuse it while calling the Program#process methods:\n      nodesPerPrograms[type] = 0;\n    }\n    // Handling node z-index\n    // TODO: z-index needs us to compute display data before hand\n    if (this.settings.zIndex && nodeZExtent[0] !== nodeZExtent[1]) nodes = (0, utils_1.zIndexOrdering)(nodeZExtent, function (node) {\n      return _this.nodeDataCache[node].zIndex;\n    }, nodes);\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      var node = nodes[i];\n      var data = this.nodeDataCache[node];\n      this.quadtree.add(node, data.x, 1 - data.y, data.size / this.width);\n      if (typeof data.label === \"string\" && !data.hidden) this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, {\n        matrix: nullCameraMatrix\n      }));\n      this.nodePrograms[data.type].process(data, data.hidden, nodesPerPrograms[data.type]++);\n      // Save the node in the highlighted set if needed\n      if (data.highlighted && !data.hidden) this.highlightedNodes.add(node);\n    }\n    this.labelGrid.organize();\n    var edgesPerPrograms = {};\n    var edges = graph.edges();\n    for (var i = 0, l = edges.length; i < l; i++) {\n      var edge = edges[i];\n      // Edge display data resolution:\n      //   1. First we get the edge's attributes\n      //   2. We optionally reduce them using the function provided by the user\n      //      Note that this function must return a total object and won't be merged\n      //   3. We apply our defaults, while running some vital checks\n      // We shallow copy edge data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, graph.getEdgeAttributes(edge));\n      if (settings.edgeReducer) attr = settings.edgeReducer(edge, attr);\n      var data = applyEdgeDefaults(this.settings, edge, attr);\n      edgesPerPrograms[data.type] = (edgesPerPrograms[data.type] || 0) + 1;\n      this.edgeDataCache[edge] = data;\n      if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.push(edge);\n      if (this.settings.zIndex) {\n        if (data.zIndex < edgeZExtent[0]) edgeZExtent[0] = data.zIndex;\n        if (data.zIndex > edgeZExtent[1]) edgeZExtent[1] = data.zIndex;\n      }\n    }\n    for (var type in this.edgePrograms) {\n      if (!this.edgePrograms.hasOwnProperty(type)) {\n        throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(type, \"\\\"!\"));\n      }\n      if (!keepArrays) this.edgePrograms[type].allocate(edgesPerPrograms[type] || 0);\n      // We reset that count here, so that we can reuse it while calling the Program#process methods:\n      edgesPerPrograms[type] = 0;\n    }\n    // Handling edge z-index\n    if (this.settings.zIndex && edgeZExtent[0] !== edgeZExtent[1]) edges = (0, utils_1.zIndexOrdering)(edgeZExtent, function (edge) {\n      return _this.edgeDataCache[edge].zIndex;\n    }, edges);\n    for (var i = 0, l = edges.length; i < l; i++) {\n      var edge = edges[i];\n      var data = this.edgeDataCache[edge];\n      var extremities = graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]];\n      var hidden = data.hidden || sourceData.hidden || targetData.hidden;\n      this.edgePrograms[data.type].process(sourceData, targetData, data, hidden, edgesPerPrograms[data.type]++);\n    }\n    for (var type in this.edgePrograms) {\n      var program = this.edgePrograms[type];\n      if (!keepArrays && typeof program.computeIndices === \"function\") program.computeIndices();\n    }\n    return this;\n  };\n  /**\n   * Method that backports potential settings updates where it's needed.\n   * @private\n   */\n  Sigma.prototype.handleSettingsUpdate = function () {\n    this.camera.minRatio = this.settings.minCameraRatio;\n    this.camera.maxRatio = this.settings.maxCameraRatio;\n    this.camera.setState(this.camera.validateState(this.camera.getState()));\n    return this;\n  };\n  /**\n   * Method that decides whether to reprocess graph or not, and then render the\n   * graph.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype._refresh = function () {\n    // Do we need to process data?\n    if (this.needToProcess) {\n      this.process();\n    } else if (this.needToSoftProcess) {\n      this.process(true);\n    }\n    // Resetting state\n    this.needToProcess = false;\n    this.needToSoftProcess = false;\n    // Rendering\n    this.render();\n    return this;\n  };\n  /**\n   * Method that schedules a `_refresh` call if none has been scheduled yet. It\n   * will then be processed next available frame.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype._scheduleRefresh = function () {\n    var _this = this;\n    if (!this.renderFrame) {\n      this.renderFrame = (0, utils_1.requestFrame)(function () {\n        _this._refresh();\n        _this.renderFrame = null;\n      });\n    }\n    return this;\n  };\n  /**\n   * Method used to render labels.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.renderLabels = function () {\n    if (!this.settings.renderLabels) return this;\n    var cameraState = this.camera.getState();\n    // Finding visible nodes to display their labels\n    var visibleNodes;\n    if (cameraState.ratio >= 1) {\n      // Camera is unzoomed so no need to ask the quadtree for visible nodes\n      visibleNodes = new Set(this.graph.nodes());\n    } else {\n      // Let's ask the quadtree\n      var viewRectangle = this.viewRectangle();\n      visibleNodes = new Set(this.quadtree.rectangle(viewRectangle.x1, 1 - viewRectangle.y1, viewRectangle.x2, 1 - viewRectangle.y2, viewRectangle.height));\n    }\n    // Selecting labels to draw\n    // TODO: drop gridsettings likewise\n    // TODO: optimize through visible nodes\n    var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity).concat(this.nodesWithForcedLabels);\n    this.displayedLabels = new Set();\n    // Drawing labels\n    var context = this.canvasContexts.labels;\n    for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n      var node = labelsToDisplay[i];\n      var data = this.nodeDataCache[node];\n      // If the node was already drawn (like if it is eligible AND has\n      // `forceLabel`), we don't want to draw it again\n      if (this.displayedLabels.has(node)) continue;\n      // If the node is hidden, we don't need to display its label obviously\n      if (data.hidden) continue;\n      var _a = this.framedGraphToViewport(data),\n        x = _a.x,\n        y = _a.y;\n      // TODO: we can cache the labels we need to render until the camera's ratio changes\n      // TODO: this should be computed in the canvas components?\n      var size = this.scaleSize(data.size);\n      if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;\n      if (!visibleNodes.has(node)) continue;\n      // TODO:\n      // Because displayed edge labels depend directly on actually rendered node\n      // labels, we need to only add to this.displayedLabels nodes whose label\n      // is rendered.\n      // This makes this.displayedLabels depend on viewport, which might become\n      // an issue once we start memoizing getLabelsToDisplay.\n      this.displayedLabels.add(node);\n      this.settings.labelRenderer(context, __assign(__assign({\n        key: node\n      }, data), {\n        size: size,\n        x: x,\n        y: y\n      }), this.settings);\n    }\n    return this;\n  };\n  /**\n   * Method used to render edge labels, based on which node labels were\n   * rendered.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.renderEdgeLabels = function () {\n    if (!this.settings.renderEdgeLabels) return this;\n    var context = this.canvasContexts.edgeLabels;\n    // Clearing\n    context.clearRect(0, 0, this.width, this.height);\n    var edgeLabelsToDisplay = (0, labels_1.edgeLabelsToDisplayFromNodes)({\n      graph: this.graph,\n      hoveredNode: this.hoveredNode,\n      displayedNodeLabels: this.displayedLabels,\n      highlightedNodes: this.highlightedNodes\n    }).concat(this.edgesWithForcedLabels);\n    var displayedLabels = new Set();\n    for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n      var edge = edgeLabelsToDisplay[i],\n        extremities = this.graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]],\n        edgeData = this.edgeDataCache[edge];\n      // If the edge was already drawn (like if it is eligible AND has\n      // `forceLabel`), we don't want to draw it again\n      if (displayedLabels.has(edge)) continue;\n      // If the edge is hidden we don't need to display its label\n      // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n      if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n        continue;\n      }\n      this.settings.edgeLabelRenderer(context, __assign(__assign({\n        key: edge\n      }, edgeData), {\n        size: this.scaleSize(edgeData.size)\n      }), __assign(__assign(__assign({\n        key: extremities[0]\n      }, sourceData), this.framedGraphToViewport(sourceData)), {\n        size: this.scaleSize(sourceData.size)\n      }), __assign(__assign(__assign({\n        key: extremities[1]\n      }, targetData), this.framedGraphToViewport(targetData)), {\n        size: this.scaleSize(targetData.size)\n      }), this.settings);\n      displayedLabels.add(edge);\n    }\n    return this;\n  };\n  /**\n   * Method used to render the highlighted nodes.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.renderHighlightedNodes = function () {\n    var _this = this;\n    var context = this.canvasContexts.hovers;\n    // Clearing\n    context.clearRect(0, 0, this.width, this.height);\n    // Rendering\n    var render = function render(node) {\n      var data = _this.nodeDataCache[node];\n      var _a = _this.framedGraphToViewport(data),\n        x = _a.x,\n        y = _a.y;\n      var size = _this.scaleSize(data.size);\n      _this.settings.hoverRenderer(context, __assign(__assign({\n        key: node\n      }, data), {\n        size: size,\n        x: x,\n        y: y\n      }), _this.settings);\n    };\n    var nodesToRender = [];\n    if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n      nodesToRender.push(this.hoveredNode);\n    }\n    this.highlightedNodes.forEach(function (node) {\n      // The hovered node has already been highlighted\n      if (node !== _this.hoveredNode) nodesToRender.push(node);\n    });\n    // Draw labels:\n    nodesToRender.forEach(function (node) {\n      return render(node);\n    });\n    // Draw WebGL nodes on top of the labels:\n    var nodesPerPrograms = {};\n    // 1. Count nodes per type:\n    nodesToRender.forEach(function (node) {\n      var type = _this.nodeDataCache[node].type;\n      nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n    });\n    // 2. Allocate for each type for the proper number of nodes\n    for (var type in this.hoverNodePrograms) {\n      this.hoverNodePrograms[type].allocate(nodesPerPrograms[type] || 0);\n      // Also reset count, to use when rendering:\n      nodesPerPrograms[type] = 0;\n    }\n    // 3. Process all nodes to render:\n    nodesToRender.forEach(function (node) {\n      var data = _this.nodeDataCache[node];\n      _this.hoverNodePrograms[data.type].process(data, data.hidden, nodesPerPrograms[data.type]++);\n    });\n    // 4. Clear hovered nodes layer:\n    this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n    // 5. Render:\n    for (var type in this.hoverNodePrograms) {\n      var program = this.hoverNodePrograms[type];\n      program.bind();\n      program.bufferData();\n      program.render({\n        matrix: this.matrix,\n        width: this.width,\n        height: this.height,\n        ratio: this.camera.ratio,\n        correctionRatio: this.correctionRatio / this.camera.ratio,\n        scalingRatio: this.pixelRatio\n      });\n    }\n  };\n  /**\n   * Method used to schedule a hover render.\n   *\n   */\n  Sigma.prototype.scheduleHighlightedNodesRender = function () {\n    var _this = this;\n    if (this.renderHighlightedNodesFrame || this.renderFrame) return;\n    this.renderHighlightedNodesFrame = (0, utils_1.requestFrame)(function () {\n      // Resetting state\n      _this.renderHighlightedNodesFrame = null;\n      // Rendering\n      _this.renderHighlightedNodes();\n      _this.renderEdgeLabels();\n    });\n  };\n  /**\n   * Method used to render.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.render = function () {\n    var _this = this;\n    this.emit(\"beforeRender\");\n    var handleEscape = function handleEscape() {\n      _this.emit(\"afterRender\");\n      return _this;\n    };\n    // If a render was scheduled, we cancel it\n    if (this.renderFrame) {\n      (0, utils_1.cancelFrame)(this.renderFrame);\n      this.renderFrame = null;\n      this.needToProcess = false;\n      this.needToSoftProcess = false;\n    }\n    // First we need to resize\n    this.resize();\n    // Clearing the canvases\n    this.clear();\n    // Recomputing useful camera-related values:\n    this.updateCachedValues();\n    // If we have no nodes we can stop right there\n    if (!this.graph.order) return handleEscape();\n    // TODO: improve this heuristic or move to the captor itself?\n    // TODO: deal with the touch captor here as well\n    var mouseCaptor = this.mouseCaptor;\n    var moving = this.camera.isAnimated() || mouseCaptor.isMoving || mouseCaptor.draggedEvents || mouseCaptor.currentWheelDirection;\n    // Then we need to extract a matrix from the camera\n    var cameraState = this.camera.getState();\n    var viewportDimensions = this.getDimensions();\n    var graphDimensions = this.getGraphDimensions();\n    var padding = this.getSetting(\"stagePadding\") || 0;\n    this.matrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding);\n    this.invMatrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding, true);\n    this.correctionRatio = (0, utils_1.getMatrixImpact)(this.matrix, cameraState, viewportDimensions);\n    // Drawing nodes\n    for (var type in this.nodePrograms) {\n      var program = this.nodePrograms[type];\n      program.bind();\n      program.bufferData();\n      program.render({\n        matrix: this.matrix,\n        width: this.width,\n        height: this.height,\n        ratio: cameraState.ratio,\n        correctionRatio: this.correctionRatio / cameraState.ratio,\n        scalingRatio: this.pixelRatio\n      });\n    }\n    // Drawing edges\n    if (!this.settings.hideEdgesOnMove || !moving) {\n      for (var type in this.edgePrograms) {\n        var program = this.edgePrograms[type];\n        program.bind();\n        program.bufferData();\n        program.render({\n          matrix: this.matrix,\n          width: this.width,\n          height: this.height,\n          ratio: cameraState.ratio,\n          correctionRatio: this.correctionRatio / cameraState.ratio,\n          scalingRatio: this.pixelRatio\n        });\n      }\n    }\n    // Do not display labels on move per setting\n    if (this.settings.hideLabelsOnMove && moving) return handleEscape();\n    this.renderLabels();\n    this.renderEdgeLabels();\n    this.renderHighlightedNodes();\n    return handleEscape();\n  };\n  /**\n   * Internal method used to update expensive and therefore cached values\n   * each time the camera state is updated.\n   */\n  Sigma.prototype.updateCachedValues = function () {\n    var ratio = this.camera.getState().ratio;\n    this.cameraSizeRatio = Math.sqrt(ratio);\n  };\n  /**---------------------------------------------------------------------------\n   * Public API.\n   **---------------------------------------------------------------------------\n   */\n  /**\n   * Method returning the renderer's camera.\n   *\n   * @return {Camera}\n   */\n  Sigma.prototype.getCamera = function () {\n    return this.camera;\n  };\n  /**\n   * Method returning the container DOM element.\n   *\n   * @return {HTMLElement}\n   */\n  Sigma.prototype.getContainer = function () {\n    return this.container;\n  };\n  /**\n   * Method returning the renderer's graph.\n   *\n   * @return {Graph}\n   */\n  Sigma.prototype.getGraph = function () {\n    return this.graph;\n  };\n  /**\n   * Method returning the mouse captor.\n   *\n   * @return {MouseCaptor}\n   */\n  Sigma.prototype.getMouseCaptor = function () {\n    return this.mouseCaptor;\n  };\n  /**\n   * Method returning the touch captor.\n   *\n   * @return {TouchCaptor}\n   */\n  Sigma.prototype.getTouchCaptor = function () {\n    return this.touchCaptor;\n  };\n  /**\n   * Method returning the current renderer's dimensions.\n   *\n   * @return {Dimensions}\n   */\n  Sigma.prototype.getDimensions = function () {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  };\n  /**\n   * Method returning the current graph's dimensions.\n   *\n   * @return {Dimensions}\n   */\n  Sigma.prototype.getGraphDimensions = function () {\n    var extent = this.customBBox || this.nodeExtent;\n    return {\n      width: extent.x[1] - extent.x[0] || 1,\n      height: extent.y[1] - extent.y[0] || 1\n    };\n  };\n  /**\n   * Method used to get all the sigma node attributes.\n   * It's usefull for example to get the position of a node\n   * and to get values that are set by the nodeReducer\n   *\n   * @param  {string} key - The node's key.\n   * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n   */\n  Sigma.prototype.getNodeDisplayData = function (key) {\n    var node = this.nodeDataCache[key];\n    return node ? Object.assign({}, node) : undefined;\n  };\n  /**\n   * Method used to get all the sigma edge attributes.\n   * It's usefull for example to get values that are set by the edgeReducer.\n   *\n   * @param  {string} key - The edge's key.\n   * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n   */\n  Sigma.prototype.getEdgeDisplayData = function (key) {\n    var edge = this.edgeDataCache[key];\n    return edge ? Object.assign({}, edge) : undefined;\n  };\n  /**\n   * Method returning a copy of the settings collection.\n   *\n   * @return {Settings} A copy of the settings collection.\n   */\n  Sigma.prototype.getSettings = function () {\n    return __assign({}, this.settings);\n  };\n  /**\n   * Method returning the current value for a given setting key.\n   *\n   * @param  {string} key - The setting key to get.\n   * @return {any} The value attached to this setting key or undefined if not found\n   */\n  Sigma.prototype.getSetting = function (key) {\n    return this.settings[key];\n  };\n  /**\n   * Method setting the value of a given setting key. Note that this will schedule\n   * a new render next frame.\n   *\n   * @param  {string} key - The setting key to set.\n   * @param  {any}    value - The value to set.\n   * @return {Sigma}\n   */\n  Sigma.prototype.setSetting = function (key, value) {\n    this.settings[key] = value;\n    (0, settings_1.validateSettings)(this.settings);\n    this.handleSettingsUpdate();\n    this.needToProcess = true; // TODO: some keys may work with only needToSoftProcess or even nothing\n    this._scheduleRefresh();\n    return this;\n  };\n  /**\n   * Method updating the value of a given setting key using the provided function.\n   * Note that this will schedule a new render next frame.\n   *\n   * @param  {string}   key     - The setting key to set.\n   * @param  {function} updater - The update function.\n   * @return {Sigma}\n   */\n  Sigma.prototype.updateSetting = function (key, updater) {\n    this.settings[key] = updater(this.settings[key]);\n    (0, settings_1.validateSettings)(this.settings);\n    this.handleSettingsUpdate();\n    this.needToProcess = true; // TODO: some keys may work with only needToSoftProcess or even nothing\n    this._scheduleRefresh();\n    return this;\n  };\n  /**\n   * Method used to resize the renderer.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.resize = function () {\n    var previousWidth = this.width,\n      previousHeight = this.height;\n    this.width = this.container.offsetWidth;\n    this.height = this.container.offsetHeight;\n    this.pixelRatio = (0, utils_1.getPixelRatio)();\n    if (this.width === 0) {\n      if (this.settings.allowInvalidContainer) this.width = 1;else throw new Error(\"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seing this error.\");\n    }\n    if (this.height === 0) {\n      if (this.settings.allowInvalidContainer) this.height = 1;else throw new Error(\"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seing this error.\");\n    }\n    // If nothing has changed, we can stop right here\n    if (previousWidth === this.width && previousHeight === this.height) return this;\n    this.emit(\"resize\");\n    // Sizing dom elements\n    for (var id in this.elements) {\n      var element = this.elements[id];\n      element.style.width = this.width + \"px\";\n      element.style.height = this.height + \"px\";\n    }\n    // Sizing canvas contexts\n    for (var id in this.canvasContexts) {\n      this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n      this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n      if (this.pixelRatio !== 1) this.canvasContexts[id].scale(this.pixelRatio, this.pixelRatio);\n    }\n    // Sizing WebGL contexts\n    for (var id in this.webGLContexts) {\n      this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n      this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n      this.webGLContexts[id].viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n    }\n    return this;\n  };\n  /**\n   * Method used to clear all the canvases.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.clear = function () {\n    this.webGLContexts.nodes.clear(this.webGLContexts.nodes.COLOR_BUFFER_BIT);\n    this.webGLContexts.edges.clear(this.webGLContexts.edges.COLOR_BUFFER_BIT);\n    this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n    this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n    this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n    this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n    return this;\n  };\n  /**\n   * Method used to refresh all computed data.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.refresh = function () {\n    this.needToProcess = true;\n    this._refresh();\n    return this;\n  };\n  /**\n   * Method used to refresh all computed data, at the next available frame.\n   * If this method has already been called this frame, then it will only render once at the next available frame.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.scheduleRefresh = function () {\n    this.needToProcess = true;\n    this._scheduleRefresh();\n    return this;\n  };\n  /**\n   * Method used to (un)zoom, while preserving the position of a viewport point.\n   * Used for instance to zoom \"on the mouse cursor\".\n   *\n   * @param viewportTarget\n   * @param newRatio\n   * @return {CameraState}\n   */\n  Sigma.prototype.getViewportZoomedState = function (viewportTarget, newRatio) {\n    var _a = this.camera.getState(),\n      ratio = _a.ratio,\n      angle = _a.angle,\n      x = _a.x,\n      y = _a.y;\n    // TODO: handle max zoom\n    var ratioDiff = newRatio / ratio;\n    var center = {\n      x: this.width / 2,\n      y: this.height / 2\n    };\n    var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n    var graphCenterPosition = this.viewportToFramedGraph(center);\n    return {\n      angle: angle,\n      x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n      y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n      ratio: newRatio\n    };\n  };\n  /**\n   * Method returning the abstract rectangle containing the graph according\n   * to the camera's state.\n   *\n   * @return {object} - The view's rectangle.\n   */\n  Sigma.prototype.viewRectangle = function () {\n    // TODO: reduce relative margin?\n    var marginX = 0 * this.width / 8,\n      marginY = 0 * this.height / 8;\n    var p1 = this.viewportToFramedGraph({\n        x: 0 - marginX,\n        y: 0 - marginY\n      }),\n      p2 = this.viewportToFramedGraph({\n        x: this.width + marginX,\n        y: 0 - marginY\n      }),\n      h = this.viewportToFramedGraph({\n        x: 0,\n        y: this.height + marginY\n      });\n    return {\n      x1: p1.x,\n      y1: p1.y,\n      x2: p2.x,\n      y2: p2.y,\n      height: p2.y - h.y\n    };\n  };\n  /**\n   * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n   * overriding anything that is used to get the translation matrix, or even the matrix itself.\n   *\n   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n   * of computations.\n   */\n  Sigma.prototype.framedGraphToViewport = function (coordinates, override) {\n    if (override === void 0) {\n      override = {};\n    }\n    var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n    var matrix = override.matrix ? override.matrix : recomputeMatrix ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0) : this.matrix;\n    var viewportPos = (0, matrices_1.multiplyVec2)(matrix, coordinates);\n    return {\n      x: (1 + viewportPos.x) * this.width / 2,\n      y: (1 - viewportPos.y) * this.height / 2\n    };\n  };\n  /**\n   * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n   * overriding anything that is used to get the translation matrix, or even the matrix itself.\n   *\n   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n   * of computations.\n   */\n  Sigma.prototype.viewportToFramedGraph = function (coordinates, override) {\n    if (override === void 0) {\n      override = {};\n    }\n    var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n    var invMatrix = override.matrix ? override.matrix : recomputeMatrix ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0, true) : this.invMatrix;\n    var res = (0, matrices_1.multiplyVec2)(invMatrix, {\n      x: coordinates.x / this.width * 2 - 1,\n      y: 1 - coordinates.y / this.height * 2\n    });\n    if (isNaN(res.x)) res.x = 0;\n    if (isNaN(res.y)) res.y = 0;\n    return res;\n  };\n  /**\n   * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n   * stage) to the graph system (the reference system of data as they are in the given graph instance).\n   *\n   * This method accepts an optional camera which can be useful if you need to translate coordinates\n   * based on a different view than the one being currently being displayed on screen.\n   *\n   * @param {Coordinates}                  viewportPoint\n   * @param {CoordinateConversionOverride} override\n   */\n  Sigma.prototype.viewportToGraph = function (viewportPoint, override) {\n    if (override === void 0) {\n      override = {};\n    }\n    return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n  };\n  /**\n   * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n   * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n   *\n   * This method accepts an optional camera which can be useful if you need to translate coordinates\n   * based on a different view than the one being currently being displayed on screen.\n   *\n   * @param {Coordinates}                  graphPoint\n   * @param {CoordinateConversionOverride} override\n   */\n  Sigma.prototype.graphToViewport = function (graphPoint, override) {\n    if (override === void 0) {\n      override = {};\n    }\n    return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n  };\n  /**\n   * Method returning the graph's bounding box.\n   *\n   * @return {{ x: Extent, y: Extent }}\n   */\n  Sigma.prototype.getBBox = function () {\n    return (0, utils_1.graphExtent)(this.graph);\n  };\n  /**\n   * Method returning the graph's custom bounding box, if any.\n   *\n   * @return {{ x: Extent, y: Extent } | null}\n   */\n  Sigma.prototype.getCustomBBox = function () {\n    return this.customBBox;\n  };\n  /**\n   * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n   *\n   * @return {Sigma}\n   */\n  Sigma.prototype.setCustomBBox = function (customBBox) {\n    this.customBBox = customBBox;\n    this._scheduleRefresh();\n    return this;\n  };\n  /**\n   * Method used to shut the container & release event listeners.\n   *\n   * @return {undefined}\n   */\n  Sigma.prototype.kill = function () {\n    var graph = this.graph;\n    // Emitting \"kill\" events so that plugins and such can cleanup\n    this.emit(\"kill\");\n    // Releasing events\n    this.removeAllListeners();\n    // Releasing camera handlers\n    this.camera.removeListener(\"updated\", this.activeListeners.camera);\n    // Releasing DOM events & captors\n    window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n    this.mouseCaptor.kill();\n    this.touchCaptor.kill();\n    // Releasing graph handlers\n    graph.removeListener(\"nodeAdded\", this.activeListeners.dropNodeGraphUpdate);\n    graph.removeListener(\"nodeDropped\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n    graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"edgeAdded\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n    graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n    graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.graphUpdate);\n    graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n    graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n    // Releasing cache & state\n    this.quadtree = new quadtree_1.default();\n    this.nodeDataCache = {};\n    this.edgeDataCache = {};\n    this.nodesWithForcedLabels = [];\n    this.edgesWithForcedLabels = [];\n    this.highlightedNodes.clear();\n    // Clearing frames\n    if (this.renderFrame) {\n      (0, utils_1.cancelFrame)(this.renderFrame);\n      this.renderFrame = null;\n    }\n    if (this.renderHighlightedNodesFrame) {\n      (0, utils_1.cancelFrame)(this.renderHighlightedNodesFrame);\n      this.renderHighlightedNodesFrame = null;\n    }\n    // Destroying canvases\n    var container = this.container;\n    while (container.firstChild) {\n      container.removeChild(container.firstChild);\n    }\n  };\n  /**\n   * Method used to scale the given size according to the camera's ratio, i.e.\n   * zooming state.\n   *\n   * @param  {number} size - The size to scale (node size, edge thickness etc.).\n   * @return {number}      - The scaled size.\n   */\n  Sigma.prototype.scaleSize = function (size) {\n    return size / this.cameraSizeRatio;\n  };\n  /**\n   * Method that returns the collection of all used canvases.\n   * At the moment, the instantiated canvases are the following, and in the\n   * following order in the DOM:\n   * - `edges`\n   * - `nodes`\n   * - `edgeLabels`\n   * - `labels`\n   * - `hovers`\n   * - `hoverNodes`\n   * - `mouse`\n   *\n   * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n   */\n  Sigma.prototype.getCanvases = function () {\n    return __assign({}, this.elements);\n  };\n  return Sigma;\n}(types_1.TypedEventEmitter);\nexports.default = Sigma;","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","__values","o","Symbol","iterator","m","next","value","done","__importDefault","mod","__esModule","defineProperty","exports","camera_1","require","mouse_1","quadtree_1","types_1","utils_1","labels_1","settings_1","touch_1","matrices_1","edge_collisions_1","applyNodeDefaults","settings","key","data","Error","concat","color","defaultNodeColor","label","undefined","size","hidden","highlighted","forceLabel","type","defaultNodeType","zIndex","applyEdgeDefaults","defaultEdgeColor","defaultEdgeType","Sigma","_super","graph","container","_this","elements","canvasContexts","webGLContexts","activeListeners","quadtree","default","labelGrid","LabelGrid","nodeDataCache","edgeDataCache","nodesWithForcedLabels","edgesWithForcedLabels","nodeExtent","x","y","matrix","identity","invMatrix","correctionRatio","customBBox","normalizationFunction","createNormalizationFunction","cameraSizeRatio","width","height","pixelRatio","getPixelRatio","displayedLabels","Set","highlightedNodes","hoveredNode","hoveredEdge","renderFrame","renderHighlightedNodesFrame","needToProcess","needToSoftProcess","checkEdgesEventsFrame","nodePrograms","hoverNodePrograms","edgePrograms","DEFAULT_SETTINGS","validateSettings","validateGraph","HTMLElement","createWebGLContext","preserveDrawingBuffer","createCanvasContext","gl","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","enable","BLEND","nodeProgramClasses","NodeProgramClass","nodes","hoverNodes","edgeProgramClasses","EdgeProgramClass","edges","resize","camera","bindCameraHandlers","mouseCaptor","mouse","touchCaptor","bindEventHandlers","bindGraphHandlers","handleSettingsUpdate","process","render","createCanvas","id","canvas","createElement","position","class","appendChild","contextOptions","antialias","getContext","options","context","_scheduleRefresh","on","mouseIsOnNode","_a","_b","nodeX","nodeY","Math","sqrt","pow","getQuadNodes","mouseGraphPosition","viewportToFramedGraph","point","getNodeAtPosition","quadNodes","minDistance","Infinity","nodeAtPosition","l","node","nodePosition","framedGraphToViewport","scaleSize","distance","handleResize","window","addEventListener","handleMove","e","baseEvent","event","preventSigmaDefault","nodeToHover","emit","scheduleHighlightedNodesRender","pos","enableEdgeHoverEvents","checkEdgeHoverEvents","requestFrame","createMouseListener","eventType","isFakeSigmaMouseEvent","original","enableEdgeWheelEvents","enableEdgeClickEvents","edge","getEdgeAtPoint","handleClick","handleRightClick","handleDoubleClick","handleWheel","handleDown","graphUpdate","softGraphUpdate","dropNodeGraphUpdate","dropEdgeGraphUpdate","clearEdgesGraphUpdate","clearGraphUpdate","payload","edgeToHover","e_1","isPixelColored","_c","viewportToGraph","graphX","graphY","transformationRatio","someEdge","_","sourceId","targetId","xs","ys","xt","yt","graphLength","graphToViewport","vp_xs","vp_ys","_d","vp_xt","vp_yt","viewportLength","filterEdges","edgeAttributes","sourcePosition","targetPosition","doEdgeCollideWithPoint","selectedEdge","highestZIndex","edges_1","edges_1_1","getEdgeAttribute","e_1_1","error","return","keepArrays","dimensions","getDimensions","nodeZExtent","edgeZExtent","clear","resizeAndClear","labelGridCellSize","graphExtent","nullCamera","nullCameraMatrix","matrixFromCamera","getState","getGraphDimensions","getSetting","nodesPerPrograms","attr","getNodeAttributes","nodeReducer","applyTo","push","allocate","zIndexOrdering","add","organize","edgesPerPrograms","getEdgeAttributes","edgeReducer","extremities","sourceData","targetData","program","computeIndices","minRatio","minCameraRatio","maxRatio","maxCameraRatio","setState","validateState","_refresh","renderLabels","cameraState","visibleNodes","ratio","viewRectangle","rectangle","x1","y1","x2","y2","labelsToDisplay","getLabelsToDisplay","labelDensity","labels","has","labelRenderedSizeThreshold","labelRenderer","renderEdgeLabels","edgeLabels","clearRect","edgeLabelsToDisplay","edgeLabelsToDisplayFromNodes","displayedNodeLabels","edgeData","edgeLabelRenderer","renderHighlightedNodes","hovers","hoverRenderer","nodesToRender","forEach","COLOR_BUFFER_BIT","bind","bufferData","scalingRatio","handleEscape","cancelFrame","updateCachedValues","order","moving","isAnimated","isMoving","draggedEvents","currentWheelDirection","viewportDimensions","graphDimensions","padding","getMatrixImpact","hideEdgesOnMove","hideLabelsOnMove","getCamera","getContainer","getGraph","getMouseCaptor","getTouchCaptor","extent","getNodeDisplayData","getEdgeDisplayData","getSettings","setSetting","updateSetting","updater","previousWidth","previousHeight","offsetWidth","offsetHeight","allowInvalidContainer","element","style","setAttribute","scale","viewport","refresh","scheduleRefresh","getViewportZoomedState","viewportTarget","newRatio","angle","ratioDiff","center","graphMousePosition","graphCenterPosition","marginX","marginY","p1","p2","h","coordinates","override","recomputeMatrix","viewportPos","multiplyVec2","res","isNaN","viewportPoint","inverse","graphPoint","getBBox","getCustomBBox","setCustomBBox","kill","removeAllListeners","removeListener","removeEventListener","firstChild","removeChild","getCanvases","TypedEventEmitter"],"sources":["/Users/declanbradley/Documents/GitHub/house-finance/node_modules/sigma/sigma.js"],"sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar camera_1 = __importDefault(require(\"./core/camera\"));\nvar mouse_1 = __importDefault(require(\"./core/captors/mouse\"));\nvar quadtree_1 = __importDefault(require(\"./core/quadtree\"));\nvar types_1 = require(\"./types\");\nvar utils_1 = require(\"./utils\");\nvar labels_1 = require(\"./core/labels\");\nvar settings_1 = require(\"./settings\");\nvar touch_1 = __importDefault(require(\"./core/captors/touch\"));\nvar matrices_1 = require(\"./utils/matrices\");\nvar edge_collisions_1 = require(\"./utils/edge-collisions\");\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings, key, data) {\n    if (!data.hasOwnProperty(\"x\") || !data.hasOwnProperty(\"y\"))\n        throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n    if (!data.color)\n        data.color = settings.defaultNodeColor;\n    if (!data.label && data.label !== \"\")\n        data.label = null;\n    if (data.label !== undefined && data.label !== null)\n        data.label = \"\" + data.label;\n    else\n        data.label = null;\n    if (!data.size)\n        data.size = 2;\n    if (!data.hasOwnProperty(\"hidden\"))\n        data.hidden = false;\n    if (!data.hasOwnProperty(\"highlighted\"))\n        data.highlighted = false;\n    if (!data.hasOwnProperty(\"forceLabel\"))\n        data.forceLabel = false;\n    if (!data.type || data.type === \"\")\n        data.type = settings.defaultNodeType;\n    if (!data.zIndex)\n        data.zIndex = 0;\n    return data;\n}\nfunction applyEdgeDefaults(settings, key, data) {\n    if (!data.color)\n        data.color = settings.defaultEdgeColor;\n    if (!data.label)\n        data.label = \"\";\n    if (!data.size)\n        data.size = 0.5;\n    if (!data.hasOwnProperty(\"hidden\"))\n        data.hidden = false;\n    if (!data.hasOwnProperty(\"forceLabel\"))\n        data.forceLabel = false;\n    if (!data.type || data.type === \"\")\n        data.type = settings.defaultEdgeType;\n    if (!data.zIndex)\n        data.zIndex = 0;\n    return data;\n}\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nvar Sigma = /** @class */ (function (_super) {\n    __extends(Sigma, _super);\n    function Sigma(graph, container, settings) {\n        if (settings === void 0) { settings = {}; }\n        var _this = _super.call(this) || this;\n        _this.elements = {};\n        _this.canvasContexts = {};\n        _this.webGLContexts = {};\n        _this.activeListeners = {};\n        _this.quadtree = new quadtree_1.default();\n        _this.labelGrid = new labels_1.LabelGrid();\n        _this.nodeDataCache = {};\n        _this.edgeDataCache = {};\n        _this.nodesWithForcedLabels = [];\n        _this.edgesWithForcedLabels = [];\n        _this.nodeExtent = { x: [0, 1], y: [0, 1] };\n        _this.matrix = (0, matrices_1.identity)();\n        _this.invMatrix = (0, matrices_1.identity)();\n        _this.correctionRatio = 1;\n        _this.customBBox = null;\n        _this.normalizationFunction = (0, utils_1.createNormalizationFunction)({\n            x: [0, 1],\n            y: [0, 1],\n        });\n        // Cache:\n        _this.cameraSizeRatio = 1;\n        // Starting dimensions and pixel ratio\n        _this.width = 0;\n        _this.height = 0;\n        _this.pixelRatio = (0, utils_1.getPixelRatio)();\n        // State\n        _this.displayedLabels = new Set();\n        _this.highlightedNodes = new Set();\n        _this.hoveredNode = null;\n        _this.hoveredEdge = null;\n        _this.renderFrame = null;\n        _this.renderHighlightedNodesFrame = null;\n        _this.needToProcess = false;\n        _this.needToSoftProcess = false;\n        _this.checkEdgesEventsFrame = null;\n        // Programs\n        _this.nodePrograms = {};\n        _this.hoverNodePrograms = {};\n        _this.edgePrograms = {};\n        _this.settings = (0, utils_1.assign)({}, settings_1.DEFAULT_SETTINGS, settings);\n        // Validating\n        (0, settings_1.validateSettings)(_this.settings);\n        (0, utils_1.validateGraph)(graph);\n        if (!(container instanceof HTMLElement))\n            throw new Error(\"Sigma: container should be an html element.\");\n        // Properties\n        _this.graph = graph;\n        _this.container = container;\n        // Initializing contexts\n        _this.createWebGLContext(\"edges\", { preserveDrawingBuffer: true });\n        _this.createCanvasContext(\"edgeLabels\");\n        _this.createWebGLContext(\"nodes\");\n        _this.createCanvasContext(\"labels\");\n        _this.createCanvasContext(\"hovers\");\n        _this.createWebGLContext(\"hoverNodes\");\n        _this.createCanvasContext(\"mouse\");\n        // Blending\n        for (var key in _this.webGLContexts) {\n            var gl = _this.webGLContexts[key];\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.enable(gl.BLEND);\n        }\n        // Loading programs\n        for (var type in _this.settings.nodeProgramClasses) {\n            var NodeProgramClass = _this.settings.nodeProgramClasses[type];\n            _this.nodePrograms[type] = new NodeProgramClass(_this.webGLContexts.nodes, _this);\n            _this.hoverNodePrograms[type] = new NodeProgramClass(_this.webGLContexts.hoverNodes, _this);\n        }\n        for (var type in _this.settings.edgeProgramClasses) {\n            var EdgeProgramClass = _this.settings.edgeProgramClasses[type];\n            _this.edgePrograms[type] = new EdgeProgramClass(_this.webGLContexts.edges, _this);\n        }\n        // Initial resize\n        _this.resize();\n        // Initializing the camera\n        _this.camera = new camera_1.default();\n        // Binding camera events\n        _this.bindCameraHandlers();\n        // Initializing captors\n        _this.mouseCaptor = new mouse_1.default(_this.elements.mouse, _this);\n        _this.touchCaptor = new touch_1.default(_this.elements.mouse, _this);\n        // Binding event handlers\n        _this.bindEventHandlers();\n        // Binding graph handlers\n        _this.bindGraphHandlers();\n        // Trigger eventual settings-related things\n        _this.handleSettingsUpdate();\n        // Processing data for the first time & render\n        _this.process();\n        _this.render();\n        return _this;\n    }\n    /**---------------------------------------------------------------------------\n     * Internal methods.\n     **---------------------------------------------------------------------------\n     */\n    /**\n     * Internal function used to create a canvas element.\n     * @param  {string} id - Context's id.\n     * @return {Sigma}\n     */\n    Sigma.prototype.createCanvas = function (id) {\n        var canvas = (0, utils_1.createElement)(\"canvas\", {\n            position: \"absolute\",\n        }, {\n            class: \"sigma-\".concat(id),\n        });\n        this.elements[id] = canvas;\n        this.container.appendChild(canvas);\n        return canvas;\n    };\n    /**\n     * Internal function used to create a canvas context and add the relevant\n     * DOM elements.\n     *\n     * @param  {string} id - Context's id.\n     * @return {Sigma}\n     */\n    Sigma.prototype.createCanvasContext = function (id) {\n        var canvas = this.createCanvas(id);\n        var contextOptions = {\n            preserveDrawingBuffer: false,\n            antialias: false,\n        };\n        this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n        return this;\n    };\n    /**\n     * Internal function used to create a canvas context and add the relevant\n     * DOM elements.\n     *\n     * @param  {string}  id      - Context's id.\n     * @param  {object?} options - #getContext params to override (optional)\n     * @return {Sigma}\n     */\n    Sigma.prototype.createWebGLContext = function (id, options) {\n        var canvas = this.createCanvas(id);\n        var contextOptions = __assign({ preserveDrawingBuffer: false, antialias: false }, (options || {}));\n        var context;\n        // First we try webgl2 for an easy performance boost\n        context = canvas.getContext(\"webgl2\", contextOptions);\n        // Else we fall back to webgl\n        if (!context)\n            context = canvas.getContext(\"webgl\", contextOptions);\n        // Edge, I am looking right at you...\n        if (!context)\n            context = canvas.getContext(\"experimental-webgl\", contextOptions);\n        this.webGLContexts[id] = context;\n        return this;\n    };\n    /**\n     * Method binding camera handlers.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.bindCameraHandlers = function () {\n        var _this = this;\n        this.activeListeners.camera = function () {\n            _this._scheduleRefresh();\n        };\n        this.camera.on(\"updated\", this.activeListeners.camera);\n        return this;\n    };\n    /**\n     * Method that checks whether or not a node collides with a given position.\n     */\n    Sigma.prototype.mouseIsOnNode = function (_a, _b, size) {\n        var x = _a.x, y = _a.y;\n        var nodeX = _b.x, nodeY = _b.y;\n        return (x > nodeX - size &&\n            x < nodeX + size &&\n            y > nodeY - size &&\n            y < nodeY + size &&\n            Math.sqrt(Math.pow(x - nodeX, 2) + Math.pow(y - nodeY, 2)) < size);\n    };\n    /**\n     * Method that returns all nodes in quad at a given position.\n     */\n    Sigma.prototype.getQuadNodes = function (position) {\n        var mouseGraphPosition = this.viewportToFramedGraph(position);\n        return this.quadtree.point(mouseGraphPosition.x, 1 - mouseGraphPosition.y);\n    };\n    /**\n     * Method that returns the closest node to a given position.\n     */\n    Sigma.prototype.getNodeAtPosition = function (position) {\n        var x = position.x, y = position.y;\n        var quadNodes = this.getQuadNodes(position);\n        // We will hover the node whose center is closest to mouse\n        var minDistance = Infinity, nodeAtPosition = null;\n        for (var i = 0, l = quadNodes.length; i < l; i++) {\n            var node = quadNodes[i];\n            var data = this.nodeDataCache[node];\n            var nodePosition = this.framedGraphToViewport(data);\n            var size = this.scaleSize(data.size);\n            if (!data.hidden && this.mouseIsOnNode(position, nodePosition, size)) {\n                var distance = Math.sqrt(Math.pow(x - nodePosition.x, 2) + Math.pow(y - nodePosition.y, 2));\n                // TODO: sort by min size also for cases where center is the same\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    nodeAtPosition = node;\n                }\n            }\n        }\n        return nodeAtPosition;\n    };\n    /**\n     * Method binding event handlers.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.bindEventHandlers = function () {\n        var _this = this;\n        // Handling window resize\n        this.activeListeners.handleResize = function () {\n            _this.needToSoftProcess = true;\n            _this._scheduleRefresh();\n        };\n        window.addEventListener(\"resize\", this.activeListeners.handleResize);\n        // Handling mouse move\n        this.activeListeners.handleMove = function (e) {\n            var baseEvent = {\n                event: e,\n                preventSigmaDefault: function () {\n                    e.preventSigmaDefault();\n                },\n            };\n            var nodeToHover = _this.getNodeAtPosition(e);\n            if (nodeToHover && _this.hoveredNode !== nodeToHover && !_this.nodeDataCache[nodeToHover].hidden) {\n                // Handling passing from one node to the other directly\n                if (_this.hoveredNode)\n                    _this.emit(\"leaveNode\", __assign(__assign({}, baseEvent), { node: _this.hoveredNode }));\n                _this.hoveredNode = nodeToHover;\n                _this.emit(\"enterNode\", __assign(__assign({}, baseEvent), { node: nodeToHover }));\n                _this.scheduleHighlightedNodesRender();\n                return;\n            }\n            // Checking if the hovered node is still hovered\n            if (_this.hoveredNode) {\n                var data = _this.nodeDataCache[_this.hoveredNode];\n                var pos = _this.framedGraphToViewport(data);\n                var size = _this.scaleSize(data.size);\n                if (!_this.mouseIsOnNode(e, pos, size)) {\n                    var node = _this.hoveredNode;\n                    _this.hoveredNode = null;\n                    _this.emit(\"leaveNode\", __assign(__assign({}, baseEvent), { node: node }));\n                    _this.scheduleHighlightedNodesRender();\n                    return;\n                }\n            }\n            if (_this.settings.enableEdgeHoverEvents === true) {\n                _this.checkEdgeHoverEvents(baseEvent);\n            }\n            else if (_this.settings.enableEdgeHoverEvents === \"debounce\") {\n                if (!_this.checkEdgesEventsFrame)\n                    _this.checkEdgesEventsFrame = (0, utils_1.requestFrame)(function () {\n                        _this.checkEdgeHoverEvents(baseEvent);\n                        _this.checkEdgesEventsFrame = null;\n                    });\n            }\n        };\n        // Handling click\n        var createMouseListener = function (eventType) {\n            return function (e) {\n                var baseEvent = {\n                    event: e,\n                    preventSigmaDefault: function () {\n                        e.preventSigmaDefault();\n                    },\n                };\n                var isFakeSigmaMouseEvent = e.original.isFakeSigmaMouseEvent;\n                var nodeAtPosition = isFakeSigmaMouseEvent ? _this.getNodeAtPosition(e) : _this.hoveredNode;\n                if (nodeAtPosition)\n                    return _this.emit(\"\".concat(eventType, \"Node\"), __assign(__assign({}, baseEvent), { node: nodeAtPosition }));\n                if (eventType === \"wheel\" ? _this.settings.enableEdgeWheelEvents : _this.settings.enableEdgeClickEvents) {\n                    var edge = _this.getEdgeAtPoint(e.x, e.y);\n                    if (edge)\n                        return _this.emit(\"\".concat(eventType, \"Edge\"), __assign(__assign({}, baseEvent), { edge: edge }));\n                }\n                return _this.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n            };\n        };\n        this.activeListeners.handleClick = createMouseListener(\"click\");\n        this.activeListeners.handleRightClick = createMouseListener(\"rightClick\");\n        this.activeListeners.handleDoubleClick = createMouseListener(\"doubleClick\");\n        this.activeListeners.handleWheel = createMouseListener(\"wheel\");\n        this.activeListeners.handleDown = createMouseListener(\"down\");\n        this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n        this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n        this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n        this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n        this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n        this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n        // TODO\n        // Deal with Touch captor events\n        return this;\n    };\n    /**\n     * Method binding graph handlers\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.bindGraphHandlers = function () {\n        var _this = this;\n        var graph = this.graph;\n        this.activeListeners.graphUpdate = function () {\n            _this.needToProcess = true;\n            _this._scheduleRefresh();\n        };\n        this.activeListeners.softGraphUpdate = function () {\n            _this.needToSoftProcess = true;\n            _this._scheduleRefresh();\n        };\n        this.activeListeners.dropNodeGraphUpdate = function (e) {\n            delete _this.nodeDataCache[e.key];\n            if (_this.hoveredNode === e.key)\n                _this.hoveredNode = null;\n            _this.activeListeners.graphUpdate();\n        };\n        this.activeListeners.dropEdgeGraphUpdate = function (e) {\n            delete _this.edgeDataCache[e.key];\n            if (_this.hoveredEdge === e.key)\n                _this.hoveredEdge = null;\n            _this.activeListeners.graphUpdate();\n        };\n        this.activeListeners.clearEdgesGraphUpdate = function () {\n            _this.edgeDataCache = {};\n            _this.hoveredEdge = null;\n            _this.activeListeners.graphUpdate();\n        };\n        this.activeListeners.clearGraphUpdate = function () {\n            _this.nodeDataCache = {};\n            _this.hoveredNode = null;\n            _this.activeListeners.clearEdgesGraphUpdate();\n        };\n        graph.on(\"nodeAdded\", this.activeListeners.graphUpdate);\n        graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n        graph.on(\"nodeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n        graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.on(\"edgeAdded\", this.activeListeners.graphUpdate);\n        graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n        graph.on(\"edgeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n        graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n        graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n        return this;\n    };\n    /**\n     * Method dealing with \"leaveEdge\" and \"enterEdge\" events.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.checkEdgeHoverEvents = function (payload) {\n        var edgeToHover = this.hoveredNode ? null : this.getEdgeAtPoint(payload.event.x, payload.event.y);\n        if (edgeToHover !== this.hoveredEdge) {\n            if (this.hoveredEdge)\n                this.emit(\"leaveEdge\", __assign(__assign({}, payload), { edge: this.hoveredEdge }));\n            if (edgeToHover)\n                this.emit(\"enterEdge\", __assign(__assign({}, payload), { edge: edgeToHover }));\n            this.hoveredEdge = edgeToHover;\n        }\n        return this;\n    };\n    /**\n     * Method looking for an edge colliding with a given point at (x, y). Returns\n     * the key of the edge if any, or null else.\n     */\n    Sigma.prototype.getEdgeAtPoint = function (x, y) {\n        var e_1, _a;\n        var _this = this;\n        var _b = this, edgeDataCache = _b.edgeDataCache, nodeDataCache = _b.nodeDataCache;\n        // Check first that pixel is colored:\n        // Note that mouse positions must be corrected by pixel ratio to correctly\n        // index the drawing buffer.\n        if (!(0, edge_collisions_1.isPixelColored)(this.webGLContexts.edges, x * this.pixelRatio, y * this.pixelRatio))\n            return null;\n        // Check for each edge if it collides with the point:\n        var _c = this.viewportToGraph({ x: x, y: y }), graphX = _c.x, graphY = _c.y;\n        // To translate edge thicknesses to the graph system, we observe by how much\n        // the length of a non-null edge is transformed to between the graph system\n        // and the viewport system:\n        var transformationRatio = 0;\n        this.graph.someEdge(function (key, _, sourceId, targetId, _a, _b) {\n            var xs = _a.x, ys = _a.y;\n            var xt = _b.x, yt = _b.y;\n            if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden)\n                return false;\n            if (xs !== xt || ys !== yt) {\n                var graphLength = Math.sqrt(Math.pow(xt - xs, 2) + Math.pow(yt - ys, 2));\n                var _c = _this.graphToViewport({ x: xs, y: ys }), vp_xs = _c.x, vp_ys = _c.y;\n                var _d = _this.graphToViewport({ x: xt, y: yt }), vp_xt = _d.x, vp_yt = _d.y;\n                var viewportLength = Math.sqrt(Math.pow(vp_xt - vp_xs, 2) + Math.pow(vp_yt - vp_ys, 2));\n                transformationRatio = graphLength / viewportLength;\n                return true;\n            }\n        });\n        // If no non-null edge has been found, return null:\n        if (!transformationRatio)\n            return null;\n        // Now we can look for matching edges:\n        var edges = this.graph.filterEdges(function (key, edgeAttributes, sourceId, targetId, sourcePosition, targetPosition) {\n            if (edgeDataCache[key].hidden || nodeDataCache[sourceId].hidden || nodeDataCache[targetId].hidden)\n                return false;\n            if ((0, edge_collisions_1.doEdgeCollideWithPoint)(graphX, graphY, sourcePosition.x, sourcePosition.y, targetPosition.x, targetPosition.y, \n            // Adapt the edge size to the zoom ratio:\n            (edgeDataCache[key].size * transformationRatio) / _this.cameraSizeRatio)) {\n                return true;\n            }\n        });\n        if (edges.length === 0)\n            return null; // no edges found\n        // if none of the edges have a zIndex, selected the most recently created one to match the rendering order\n        var selectedEdge = edges[edges.length - 1];\n        // otherwise select edge with highest zIndex\n        var highestZIndex = -Infinity;\n        try {\n            for (var edges_1 = __values(edges), edges_1_1 = edges_1.next(); !edges_1_1.done; edges_1_1 = edges_1.next()) {\n                var edge = edges_1_1.value;\n                var zIndex = this.graph.getEdgeAttribute(edge, \"zIndex\");\n                if (zIndex >= highestZIndex) {\n                    selectedEdge = edge;\n                    highestZIndex = zIndex;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (edges_1_1 && !edges_1_1.done && (_a = edges_1.return)) _a.call(edges_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return selectedEdge;\n    };\n    /**\n     * Method used to process the whole graph's data.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.process = function (keepArrays) {\n        var _this = this;\n        if (keepArrays === void 0) { keepArrays = false; }\n        var graph = this.graph;\n        var settings = this.settings;\n        var dimensions = this.getDimensions();\n        var nodeZExtent = [Infinity, -Infinity];\n        var edgeZExtent = [Infinity, -Infinity];\n        // Clearing the quad\n        this.quadtree.clear();\n        // Resetting the label grid\n        // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n        this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n        // Clear the highlightedNodes\n        this.highlightedNodes = new Set();\n        // Computing extents\n        this.nodeExtent = (0, utils_1.graphExtent)(graph);\n        // Resetting `forceLabel` indices\n        this.nodesWithForcedLabels = [];\n        this.edgesWithForcedLabels = [];\n        // NOTE: it is important to compute this matrix after computing the node's extent\n        // because #.getGraphDimensions relies on it\n        var nullCamera = new camera_1.default();\n        var nullCameraMatrix = (0, utils_1.matrixFromCamera)(nullCamera.getState(), this.getDimensions(), this.getGraphDimensions(), this.getSetting(\"stagePadding\") || 0);\n        // Rescaling function\n        this.normalizationFunction = (0, utils_1.createNormalizationFunction)(this.customBBox || this.nodeExtent);\n        var nodesPerPrograms = {};\n        var nodes = graph.nodes();\n        for (var i = 0, l = nodes.length; i < l; i++) {\n            var node = nodes[i];\n            // Node display data resolution:\n            //   1. First we get the node's attributes\n            //   2. We optionally reduce them using the function provided by the user\n            //      Note that this function must return a total object and won't be merged\n            //   3. We apply our defaults, while running some vital checks\n            //   4. We apply the normalization function\n            // We shallow copy node data to avoid dangerous behaviors from reducers\n            var attr = Object.assign({}, graph.getNodeAttributes(node));\n            if (settings.nodeReducer)\n                attr = settings.nodeReducer(node, attr);\n            var data = applyNodeDefaults(this.settings, node, attr);\n            nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n            this.nodeDataCache[node] = data;\n            this.normalizationFunction.applyTo(data);\n            if (data.forceLabel)\n                this.nodesWithForcedLabels.push(node);\n            if (this.settings.zIndex) {\n                if (data.zIndex < nodeZExtent[0])\n                    nodeZExtent[0] = data.zIndex;\n                if (data.zIndex > nodeZExtent[1])\n                    nodeZExtent[1] = data.zIndex;\n            }\n        }\n        for (var type in this.nodePrograms) {\n            if (!this.nodePrograms.hasOwnProperty(type)) {\n                throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n            }\n            if (!keepArrays)\n                this.nodePrograms[type].allocate(nodesPerPrograms[type] || 0);\n            // We reset that count here, so that we can reuse it while calling the Program#process methods:\n            nodesPerPrograms[type] = 0;\n        }\n        // Handling node z-index\n        // TODO: z-index needs us to compute display data before hand\n        if (this.settings.zIndex && nodeZExtent[0] !== nodeZExtent[1])\n            nodes = (0, utils_1.zIndexOrdering)(nodeZExtent, function (node) { return _this.nodeDataCache[node].zIndex; }, nodes);\n        for (var i = 0, l = nodes.length; i < l; i++) {\n            var node = nodes[i];\n            var data = this.nodeDataCache[node];\n            this.quadtree.add(node, data.x, 1 - data.y, data.size / this.width);\n            if (typeof data.label === \"string\" && !data.hidden)\n                this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, { matrix: nullCameraMatrix }));\n            this.nodePrograms[data.type].process(data, data.hidden, nodesPerPrograms[data.type]++);\n            // Save the node in the highlighted set if needed\n            if (data.highlighted && !data.hidden)\n                this.highlightedNodes.add(node);\n        }\n        this.labelGrid.organize();\n        var edgesPerPrograms = {};\n        var edges = graph.edges();\n        for (var i = 0, l = edges.length; i < l; i++) {\n            var edge = edges[i];\n            // Edge display data resolution:\n            //   1. First we get the edge's attributes\n            //   2. We optionally reduce them using the function provided by the user\n            //      Note that this function must return a total object and won't be merged\n            //   3. We apply our defaults, while running some vital checks\n            // We shallow copy edge data to avoid dangerous behaviors from reducers\n            var attr = Object.assign({}, graph.getEdgeAttributes(edge));\n            if (settings.edgeReducer)\n                attr = settings.edgeReducer(edge, attr);\n            var data = applyEdgeDefaults(this.settings, edge, attr);\n            edgesPerPrograms[data.type] = (edgesPerPrograms[data.type] || 0) + 1;\n            this.edgeDataCache[edge] = data;\n            if (data.forceLabel && !data.hidden)\n                this.edgesWithForcedLabels.push(edge);\n            if (this.settings.zIndex) {\n                if (data.zIndex < edgeZExtent[0])\n                    edgeZExtent[0] = data.zIndex;\n                if (data.zIndex > edgeZExtent[1])\n                    edgeZExtent[1] = data.zIndex;\n            }\n        }\n        for (var type in this.edgePrograms) {\n            if (!this.edgePrograms.hasOwnProperty(type)) {\n                throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(type, \"\\\"!\"));\n            }\n            if (!keepArrays)\n                this.edgePrograms[type].allocate(edgesPerPrograms[type] || 0);\n            // We reset that count here, so that we can reuse it while calling the Program#process methods:\n            edgesPerPrograms[type] = 0;\n        }\n        // Handling edge z-index\n        if (this.settings.zIndex && edgeZExtent[0] !== edgeZExtent[1])\n            edges = (0, utils_1.zIndexOrdering)(edgeZExtent, function (edge) { return _this.edgeDataCache[edge].zIndex; }, edges);\n        for (var i = 0, l = edges.length; i < l; i++) {\n            var edge = edges[i];\n            var data = this.edgeDataCache[edge];\n            var extremities = graph.extremities(edge), sourceData = this.nodeDataCache[extremities[0]], targetData = this.nodeDataCache[extremities[1]];\n            var hidden = data.hidden || sourceData.hidden || targetData.hidden;\n            this.edgePrograms[data.type].process(sourceData, targetData, data, hidden, edgesPerPrograms[data.type]++);\n        }\n        for (var type in this.edgePrograms) {\n            var program = this.edgePrograms[type];\n            if (!keepArrays && typeof program.computeIndices === \"function\")\n                program.computeIndices();\n        }\n        return this;\n    };\n    /**\n     * Method that backports potential settings updates where it's needed.\n     * @private\n     */\n    Sigma.prototype.handleSettingsUpdate = function () {\n        this.camera.minRatio = this.settings.minCameraRatio;\n        this.camera.maxRatio = this.settings.maxCameraRatio;\n        this.camera.setState(this.camera.validateState(this.camera.getState()));\n        return this;\n    };\n    /**\n     * Method that decides whether to reprocess graph or not, and then render the\n     * graph.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype._refresh = function () {\n        // Do we need to process data?\n        if (this.needToProcess) {\n            this.process();\n        }\n        else if (this.needToSoftProcess) {\n            this.process(true);\n        }\n        // Resetting state\n        this.needToProcess = false;\n        this.needToSoftProcess = false;\n        // Rendering\n        this.render();\n        return this;\n    };\n    /**\n     * Method that schedules a `_refresh` call if none has been scheduled yet. It\n     * will then be processed next available frame.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype._scheduleRefresh = function () {\n        var _this = this;\n        if (!this.renderFrame) {\n            this.renderFrame = (0, utils_1.requestFrame)(function () {\n                _this._refresh();\n                _this.renderFrame = null;\n            });\n        }\n        return this;\n    };\n    /**\n     * Method used to render labels.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.renderLabels = function () {\n        if (!this.settings.renderLabels)\n            return this;\n        var cameraState = this.camera.getState();\n        // Finding visible nodes to display their labels\n        var visibleNodes;\n        if (cameraState.ratio >= 1) {\n            // Camera is unzoomed so no need to ask the quadtree for visible nodes\n            visibleNodes = new Set(this.graph.nodes());\n        }\n        else {\n            // Let's ask the quadtree\n            var viewRectangle = this.viewRectangle();\n            visibleNodes = new Set(this.quadtree.rectangle(viewRectangle.x1, 1 - viewRectangle.y1, viewRectangle.x2, 1 - viewRectangle.y2, viewRectangle.height));\n        }\n        // Selecting labels to draw\n        // TODO: drop gridsettings likewise\n        // TODO: optimize through visible nodes\n        var labelsToDisplay = this.labelGrid\n            .getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity)\n            .concat(this.nodesWithForcedLabels);\n        this.displayedLabels = new Set();\n        // Drawing labels\n        var context = this.canvasContexts.labels;\n        for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n            var node = labelsToDisplay[i];\n            var data = this.nodeDataCache[node];\n            // If the node was already drawn (like if it is eligible AND has\n            // `forceLabel`), we don't want to draw it again\n            if (this.displayedLabels.has(node))\n                continue;\n            // If the node is hidden, we don't need to display its label obviously\n            if (data.hidden)\n                continue;\n            var _a = this.framedGraphToViewport(data), x = _a.x, y = _a.y;\n            // TODO: we can cache the labels we need to render until the camera's ratio changes\n            // TODO: this should be computed in the canvas components?\n            var size = this.scaleSize(data.size);\n            if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold)\n                continue;\n            if (!visibleNodes.has(node))\n                continue;\n            // TODO:\n            // Because displayed edge labels depend directly on actually rendered node\n            // labels, we need to only add to this.displayedLabels nodes whose label\n            // is rendered.\n            // This makes this.displayedLabels depend on viewport, which might become\n            // an issue once we start memoizing getLabelsToDisplay.\n            this.displayedLabels.add(node);\n            this.settings.labelRenderer(context, __assign(__assign({ key: node }, data), { size: size, x: x, y: y }), this.settings);\n        }\n        return this;\n    };\n    /**\n     * Method used to render edge labels, based on which node labels were\n     * rendered.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.renderEdgeLabels = function () {\n        if (!this.settings.renderEdgeLabels)\n            return this;\n        var context = this.canvasContexts.edgeLabels;\n        // Clearing\n        context.clearRect(0, 0, this.width, this.height);\n        var edgeLabelsToDisplay = (0, labels_1.edgeLabelsToDisplayFromNodes)({\n            graph: this.graph,\n            hoveredNode: this.hoveredNode,\n            displayedNodeLabels: this.displayedLabels,\n            highlightedNodes: this.highlightedNodes,\n        }).concat(this.edgesWithForcedLabels);\n        var displayedLabels = new Set();\n        for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n            var edge = edgeLabelsToDisplay[i], extremities = this.graph.extremities(edge), sourceData = this.nodeDataCache[extremities[0]], targetData = this.nodeDataCache[extremities[1]], edgeData = this.edgeDataCache[edge];\n            // If the edge was already drawn (like if it is eligible AND has\n            // `forceLabel`), we don't want to draw it again\n            if (displayedLabels.has(edge))\n                continue;\n            // If the edge is hidden we don't need to display its label\n            // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n            if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n                continue;\n            }\n            this.settings.edgeLabelRenderer(context, __assign(__assign({ key: edge }, edgeData), { size: this.scaleSize(edgeData.size) }), __assign(__assign(__assign({ key: extremities[0] }, sourceData), this.framedGraphToViewport(sourceData)), { size: this.scaleSize(sourceData.size) }), __assign(__assign(__assign({ key: extremities[1] }, targetData), this.framedGraphToViewport(targetData)), { size: this.scaleSize(targetData.size) }), this.settings);\n            displayedLabels.add(edge);\n        }\n        return this;\n    };\n    /**\n     * Method used to render the highlighted nodes.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.renderHighlightedNodes = function () {\n        var _this = this;\n        var context = this.canvasContexts.hovers;\n        // Clearing\n        context.clearRect(0, 0, this.width, this.height);\n        // Rendering\n        var render = function (node) {\n            var data = _this.nodeDataCache[node];\n            var _a = _this.framedGraphToViewport(data), x = _a.x, y = _a.y;\n            var size = _this.scaleSize(data.size);\n            _this.settings.hoverRenderer(context, __assign(__assign({ key: node }, data), { size: size, x: x, y: y }), _this.settings);\n        };\n        var nodesToRender = [];\n        if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n            nodesToRender.push(this.hoveredNode);\n        }\n        this.highlightedNodes.forEach(function (node) {\n            // The hovered node has already been highlighted\n            if (node !== _this.hoveredNode)\n                nodesToRender.push(node);\n        });\n        // Draw labels:\n        nodesToRender.forEach(function (node) { return render(node); });\n        // Draw WebGL nodes on top of the labels:\n        var nodesPerPrograms = {};\n        // 1. Count nodes per type:\n        nodesToRender.forEach(function (node) {\n            var type = _this.nodeDataCache[node].type;\n            nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n        });\n        // 2. Allocate for each type for the proper number of nodes\n        for (var type in this.hoverNodePrograms) {\n            this.hoverNodePrograms[type].allocate(nodesPerPrograms[type] || 0);\n            // Also reset count, to use when rendering:\n            nodesPerPrograms[type] = 0;\n        }\n        // 3. Process all nodes to render:\n        nodesToRender.forEach(function (node) {\n            var data = _this.nodeDataCache[node];\n            _this.hoverNodePrograms[data.type].process(data, data.hidden, nodesPerPrograms[data.type]++);\n        });\n        // 4. Clear hovered nodes layer:\n        this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n        // 5. Render:\n        for (var type in this.hoverNodePrograms) {\n            var program = this.hoverNodePrograms[type];\n            program.bind();\n            program.bufferData();\n            program.render({\n                matrix: this.matrix,\n                width: this.width,\n                height: this.height,\n                ratio: this.camera.ratio,\n                correctionRatio: this.correctionRatio / this.camera.ratio,\n                scalingRatio: this.pixelRatio,\n            });\n        }\n    };\n    /**\n     * Method used to schedule a hover render.\n     *\n     */\n    Sigma.prototype.scheduleHighlightedNodesRender = function () {\n        var _this = this;\n        if (this.renderHighlightedNodesFrame || this.renderFrame)\n            return;\n        this.renderHighlightedNodesFrame = (0, utils_1.requestFrame)(function () {\n            // Resetting state\n            _this.renderHighlightedNodesFrame = null;\n            // Rendering\n            _this.renderHighlightedNodes();\n            _this.renderEdgeLabels();\n        });\n    };\n    /**\n     * Method used to render.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.render = function () {\n        var _this = this;\n        this.emit(\"beforeRender\");\n        var handleEscape = function () {\n            _this.emit(\"afterRender\");\n            return _this;\n        };\n        // If a render was scheduled, we cancel it\n        if (this.renderFrame) {\n            (0, utils_1.cancelFrame)(this.renderFrame);\n            this.renderFrame = null;\n            this.needToProcess = false;\n            this.needToSoftProcess = false;\n        }\n        // First we need to resize\n        this.resize();\n        // Clearing the canvases\n        this.clear();\n        // Recomputing useful camera-related values:\n        this.updateCachedValues();\n        // If we have no nodes we can stop right there\n        if (!this.graph.order)\n            return handleEscape();\n        // TODO: improve this heuristic or move to the captor itself?\n        // TODO: deal with the touch captor here as well\n        var mouseCaptor = this.mouseCaptor;\n        var moving = this.camera.isAnimated() ||\n            mouseCaptor.isMoving ||\n            mouseCaptor.draggedEvents ||\n            mouseCaptor.currentWheelDirection;\n        // Then we need to extract a matrix from the camera\n        var cameraState = this.camera.getState();\n        var viewportDimensions = this.getDimensions();\n        var graphDimensions = this.getGraphDimensions();\n        var padding = this.getSetting(\"stagePadding\") || 0;\n        this.matrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding);\n        this.invMatrix = (0, utils_1.matrixFromCamera)(cameraState, viewportDimensions, graphDimensions, padding, true);\n        this.correctionRatio = (0, utils_1.getMatrixImpact)(this.matrix, cameraState, viewportDimensions);\n        // Drawing nodes\n        for (var type in this.nodePrograms) {\n            var program = this.nodePrograms[type];\n            program.bind();\n            program.bufferData();\n            program.render({\n                matrix: this.matrix,\n                width: this.width,\n                height: this.height,\n                ratio: cameraState.ratio,\n                correctionRatio: this.correctionRatio / cameraState.ratio,\n                scalingRatio: this.pixelRatio,\n            });\n        }\n        // Drawing edges\n        if (!this.settings.hideEdgesOnMove || !moving) {\n            for (var type in this.edgePrograms) {\n                var program = this.edgePrograms[type];\n                program.bind();\n                program.bufferData();\n                program.render({\n                    matrix: this.matrix,\n                    width: this.width,\n                    height: this.height,\n                    ratio: cameraState.ratio,\n                    correctionRatio: this.correctionRatio / cameraState.ratio,\n                    scalingRatio: this.pixelRatio,\n                });\n            }\n        }\n        // Do not display labels on move per setting\n        if (this.settings.hideLabelsOnMove && moving)\n            return handleEscape();\n        this.renderLabels();\n        this.renderEdgeLabels();\n        this.renderHighlightedNodes();\n        return handleEscape();\n    };\n    /**\n     * Internal method used to update expensive and therefore cached values\n     * each time the camera state is updated.\n     */\n    Sigma.prototype.updateCachedValues = function () {\n        var ratio = this.camera.getState().ratio;\n        this.cameraSizeRatio = Math.sqrt(ratio);\n    };\n    /**---------------------------------------------------------------------------\n     * Public API.\n     **---------------------------------------------------------------------------\n     */\n    /**\n     * Method returning the renderer's camera.\n     *\n     * @return {Camera}\n     */\n    Sigma.prototype.getCamera = function () {\n        return this.camera;\n    };\n    /**\n     * Method returning the container DOM element.\n     *\n     * @return {HTMLElement}\n     */\n    Sigma.prototype.getContainer = function () {\n        return this.container;\n    };\n    /**\n     * Method returning the renderer's graph.\n     *\n     * @return {Graph}\n     */\n    Sigma.prototype.getGraph = function () {\n        return this.graph;\n    };\n    /**\n     * Method returning the mouse captor.\n     *\n     * @return {MouseCaptor}\n     */\n    Sigma.prototype.getMouseCaptor = function () {\n        return this.mouseCaptor;\n    };\n    /**\n     * Method returning the touch captor.\n     *\n     * @return {TouchCaptor}\n     */\n    Sigma.prototype.getTouchCaptor = function () {\n        return this.touchCaptor;\n    };\n    /**\n     * Method returning the current renderer's dimensions.\n     *\n     * @return {Dimensions}\n     */\n    Sigma.prototype.getDimensions = function () {\n        return { width: this.width, height: this.height };\n    };\n    /**\n     * Method returning the current graph's dimensions.\n     *\n     * @return {Dimensions}\n     */\n    Sigma.prototype.getGraphDimensions = function () {\n        var extent = this.customBBox || this.nodeExtent;\n        return {\n            width: extent.x[1] - extent.x[0] || 1,\n            height: extent.y[1] - extent.y[0] || 1,\n        };\n    };\n    /**\n     * Method used to get all the sigma node attributes.\n     * It's usefull for example to get the position of a node\n     * and to get values that are set by the nodeReducer\n     *\n     * @param  {string} key - The node's key.\n     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n     */\n    Sigma.prototype.getNodeDisplayData = function (key) {\n        var node = this.nodeDataCache[key];\n        return node ? Object.assign({}, node) : undefined;\n    };\n    /**\n     * Method used to get all the sigma edge attributes.\n     * It's usefull for example to get values that are set by the edgeReducer.\n     *\n     * @param  {string} key - The edge's key.\n     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n     */\n    Sigma.prototype.getEdgeDisplayData = function (key) {\n        var edge = this.edgeDataCache[key];\n        return edge ? Object.assign({}, edge) : undefined;\n    };\n    /**\n     * Method returning a copy of the settings collection.\n     *\n     * @return {Settings} A copy of the settings collection.\n     */\n    Sigma.prototype.getSettings = function () {\n        return __assign({}, this.settings);\n    };\n    /**\n     * Method returning the current value for a given setting key.\n     *\n     * @param  {string} key - The setting key to get.\n     * @return {any} The value attached to this setting key or undefined if not found\n     */\n    Sigma.prototype.getSetting = function (key) {\n        return this.settings[key];\n    };\n    /**\n     * Method setting the value of a given setting key. Note that this will schedule\n     * a new render next frame.\n     *\n     * @param  {string} key - The setting key to set.\n     * @param  {any}    value - The value to set.\n     * @return {Sigma}\n     */\n    Sigma.prototype.setSetting = function (key, value) {\n        this.settings[key] = value;\n        (0, settings_1.validateSettings)(this.settings);\n        this.handleSettingsUpdate();\n        this.needToProcess = true; // TODO: some keys may work with only needToSoftProcess or even nothing\n        this._scheduleRefresh();\n        return this;\n    };\n    /**\n     * Method updating the value of a given setting key using the provided function.\n     * Note that this will schedule a new render next frame.\n     *\n     * @param  {string}   key     - The setting key to set.\n     * @param  {function} updater - The update function.\n     * @return {Sigma}\n     */\n    Sigma.prototype.updateSetting = function (key, updater) {\n        this.settings[key] = updater(this.settings[key]);\n        (0, settings_1.validateSettings)(this.settings);\n        this.handleSettingsUpdate();\n        this.needToProcess = true; // TODO: some keys may work with only needToSoftProcess or even nothing\n        this._scheduleRefresh();\n        return this;\n    };\n    /**\n     * Method used to resize the renderer.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.resize = function () {\n        var previousWidth = this.width, previousHeight = this.height;\n        this.width = this.container.offsetWidth;\n        this.height = this.container.offsetHeight;\n        this.pixelRatio = (0, utils_1.getPixelRatio)();\n        if (this.width === 0) {\n            if (this.settings.allowInvalidContainer)\n                this.width = 1;\n            else\n                throw new Error(\"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seing this error.\");\n        }\n        if (this.height === 0) {\n            if (this.settings.allowInvalidContainer)\n                this.height = 1;\n            else\n                throw new Error(\"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seing this error.\");\n        }\n        // If nothing has changed, we can stop right here\n        if (previousWidth === this.width && previousHeight === this.height)\n            return this;\n        this.emit(\"resize\");\n        // Sizing dom elements\n        for (var id in this.elements) {\n            var element = this.elements[id];\n            element.style.width = this.width + \"px\";\n            element.style.height = this.height + \"px\";\n        }\n        // Sizing canvas contexts\n        for (var id in this.canvasContexts) {\n            this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n            this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n            if (this.pixelRatio !== 1)\n                this.canvasContexts[id].scale(this.pixelRatio, this.pixelRatio);\n        }\n        // Sizing WebGL contexts\n        for (var id in this.webGLContexts) {\n            this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n            this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n            this.webGLContexts[id].viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n        }\n        return this;\n    };\n    /**\n     * Method used to clear all the canvases.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.clear = function () {\n        this.webGLContexts.nodes.clear(this.webGLContexts.nodes.COLOR_BUFFER_BIT);\n        this.webGLContexts.edges.clear(this.webGLContexts.edges.COLOR_BUFFER_BIT);\n        this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n        this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n        this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n        this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n        return this;\n    };\n    /**\n     * Method used to refresh all computed data.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.refresh = function () {\n        this.needToProcess = true;\n        this._refresh();\n        return this;\n    };\n    /**\n     * Method used to refresh all computed data, at the next available frame.\n     * If this method has already been called this frame, then it will only render once at the next available frame.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.scheduleRefresh = function () {\n        this.needToProcess = true;\n        this._scheduleRefresh();\n        return this;\n    };\n    /**\n     * Method used to (un)zoom, while preserving the position of a viewport point.\n     * Used for instance to zoom \"on the mouse cursor\".\n     *\n     * @param viewportTarget\n     * @param newRatio\n     * @return {CameraState}\n     */\n    Sigma.prototype.getViewportZoomedState = function (viewportTarget, newRatio) {\n        var _a = this.camera.getState(), ratio = _a.ratio, angle = _a.angle, x = _a.x, y = _a.y;\n        // TODO: handle max zoom\n        var ratioDiff = newRatio / ratio;\n        var center = {\n            x: this.width / 2,\n            y: this.height / 2,\n        };\n        var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n        var graphCenterPosition = this.viewportToFramedGraph(center);\n        return {\n            angle: angle,\n            x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n            y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n            ratio: newRatio,\n        };\n    };\n    /**\n     * Method returning the abstract rectangle containing the graph according\n     * to the camera's state.\n     *\n     * @return {object} - The view's rectangle.\n     */\n    Sigma.prototype.viewRectangle = function () {\n        // TODO: reduce relative margin?\n        var marginX = (0 * this.width) / 8, marginY = (0 * this.height) / 8;\n        var p1 = this.viewportToFramedGraph({ x: 0 - marginX, y: 0 - marginY }), p2 = this.viewportToFramedGraph({ x: this.width + marginX, y: 0 - marginY }), h = this.viewportToFramedGraph({ x: 0, y: this.height + marginY });\n        return {\n            x1: p1.x,\n            y1: p1.y,\n            x2: p2.x,\n            y2: p2.y,\n            height: p2.y - h.y,\n        };\n    };\n    /**\n     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n    Sigma.prototype.framedGraphToViewport = function (coordinates, override) {\n        if (override === void 0) { override = {}; }\n        var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n        var matrix = override.matrix\n            ? override.matrix\n            : recomputeMatrix\n                ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0)\n                : this.matrix;\n        var viewportPos = (0, matrices_1.multiplyVec2)(matrix, coordinates);\n        return {\n            x: ((1 + viewportPos.x) * this.width) / 2,\n            y: ((1 - viewportPos.y) * this.height) / 2,\n        };\n    };\n    /**\n     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n    Sigma.prototype.viewportToFramedGraph = function (coordinates, override) {\n        if (override === void 0) { override = {}; }\n        var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n        var invMatrix = override.matrix\n            ? override.matrix\n            : recomputeMatrix\n                ? (0, utils_1.matrixFromCamera)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0, true)\n                : this.invMatrix;\n        var res = (0, matrices_1.multiplyVec2)(invMatrix, {\n            x: (coordinates.x / this.width) * 2 - 1,\n            y: 1 - (coordinates.y / this.height) * 2,\n        });\n        if (isNaN(res.x))\n            res.x = 0;\n        if (isNaN(res.y))\n            res.y = 0;\n        return res;\n    };\n    /**\n     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n     * stage) to the graph system (the reference system of data as they are in the given graph instance).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  viewportPoint\n     * @param {CoordinateConversionOverride} override\n     */\n    Sigma.prototype.viewportToGraph = function (viewportPoint, override) {\n        if (override === void 0) { override = {}; }\n        return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n    };\n    /**\n     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  graphPoint\n     * @param {CoordinateConversionOverride} override\n     */\n    Sigma.prototype.graphToViewport = function (graphPoint, override) {\n        if (override === void 0) { override = {}; }\n        return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n    };\n    /**\n     * Method returning the graph's bounding box.\n     *\n     * @return {{ x: Extent, y: Extent }}\n     */\n    Sigma.prototype.getBBox = function () {\n        return (0, utils_1.graphExtent)(this.graph);\n    };\n    /**\n     * Method returning the graph's custom bounding box, if any.\n     *\n     * @return {{ x: Extent, y: Extent } | null}\n     */\n    Sigma.prototype.getCustomBBox = function () {\n        return this.customBBox;\n    };\n    /**\n     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n     *\n     * @return {Sigma}\n     */\n    Sigma.prototype.setCustomBBox = function (customBBox) {\n        this.customBBox = customBBox;\n        this._scheduleRefresh();\n        return this;\n    };\n    /**\n     * Method used to shut the container & release event listeners.\n     *\n     * @return {undefined}\n     */\n    Sigma.prototype.kill = function () {\n        var graph = this.graph;\n        // Emitting \"kill\" events so that plugins and such can cleanup\n        this.emit(\"kill\");\n        // Releasing events\n        this.removeAllListeners();\n        // Releasing camera handlers\n        this.camera.removeListener(\"updated\", this.activeListeners.camera);\n        // Releasing DOM events & captors\n        window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n        this.mouseCaptor.kill();\n        this.touchCaptor.kill();\n        // Releasing graph handlers\n        graph.removeListener(\"nodeAdded\", this.activeListeners.dropNodeGraphUpdate);\n        graph.removeListener(\"nodeDropped\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n        graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"edgeAdded\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n        graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.softGraphUpdate);\n        graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.graphUpdate);\n        graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n        graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n        // Releasing cache & state\n        this.quadtree = new quadtree_1.default();\n        this.nodeDataCache = {};\n        this.edgeDataCache = {};\n        this.nodesWithForcedLabels = [];\n        this.edgesWithForcedLabels = [];\n        this.highlightedNodes.clear();\n        // Clearing frames\n        if (this.renderFrame) {\n            (0, utils_1.cancelFrame)(this.renderFrame);\n            this.renderFrame = null;\n        }\n        if (this.renderHighlightedNodesFrame) {\n            (0, utils_1.cancelFrame)(this.renderHighlightedNodesFrame);\n            this.renderHighlightedNodesFrame = null;\n        }\n        // Destroying canvases\n        var container = this.container;\n        while (container.firstChild)\n            container.removeChild(container.firstChild);\n    };\n    /**\n     * Method used to scale the given size according to the camera's ratio, i.e.\n     * zooming state.\n     *\n     * @param  {number} size - The size to scale (node size, edge thickness etc.).\n     * @return {number}      - The scaled size.\n     */\n    Sigma.prototype.scaleSize = function (size) {\n        return size / this.cameraSizeRatio;\n    };\n    /**\n     * Method that returns the collection of all used canvases.\n     * At the moment, the instantiated canvases are the following, and in the\n     * following order in the DOM:\n     * - `edges`\n     * - `nodes`\n     * - `edgeLabels`\n     * - `labels`\n     * - `hovers`\n     * - `hoverNodes`\n     * - `mouse`\n     *\n     * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n     */\n    Sigma.prototype.getCanvases = function () {\n        return __assign({}, this.elements);\n    };\n    return Sigma;\n}(types_1.TypedEventEmitter));\nexports.default = Sigma;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}