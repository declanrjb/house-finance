{"ast":null,"code":"/* eslint no-self-compare: 0 */\n/**\n * Graphology Browser GEXF Parser\n * ===============================\n *\n * Browser version of the graphology GEXF parser using DOMParser to function.\n */\nvar isGraphConstructor = require('graphology-utils/is-graph-constructor');\nvar mergeEdge = require('graphology-utils/add-edge').mergeEdge;\nvar toMixed = require('graphology-operators/to-mixed');\nvar toMulti = require('graphology-operators/to-multi');\nvar helpers = require('../common/helpers.js');\nvar cast = helpers.cast;\n\n/**\n * Function checking whether the given value is a NaN.\n *\n * @param  {any} value - Value to test.\n * @return {boolean}\n */\nfunction isReallyNaN(value) {\n  return value !== value;\n}\n\n/**\n * Function used to convert a viz:color attribute into a CSS rgba? string.\n *\n * @param  {Node}   element - DOM element.\n * @return {string}\n */\nfunction toRGBString(element) {\n  var a = element.getAttribute('a'),\n    r = element.getAttribute('r'),\n    g = element.getAttribute('g'),\n    b = element.getAttribute('b');\n  return a ? 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')' : 'rgb(' + r + ',' + g + ',' + b + ')';\n}\n\n/**\n * Function returning the first matching tag of the `viz` namespace matching\n * the desired tag name.\n *\n * @param  {Node}   element - Target DOM element.\n * @param  {string} name    - Tag name.\n * @return {Node}\n */\nfunction getFirstMatchingVizTag(element, name) {\n  var vizElement = element.getElementsByTagName('viz:' + name)[0];\n  if (!vizElement) vizElement = element.getElementsByTagNameNS('viz', name)[0];\n  if (!vizElement) vizElement = element.getElementsByTagName(name)[0];\n  return vizElement;\n}\n\n/**\n * Function used to collect meta information.\n *\n * @param  {Array<Node>} elements - Target DOM element.\n * @return {object}\n */\nfunction collectMeta(elements) {\n  var meta = {},\n    element,\n    value;\n  for (var i = 0, l = elements.length; i < l; i++) {\n    element = elements[i];\n    if (element.nodeName === '#text') continue;\n    value = element.textContent.trim();\n    if (value) meta[element.tagName.toLowerCase()] = element.textContent;\n  }\n  return meta;\n}\n\n/**\n * Function used to extract the model from the right elements.\n *\n * @param  {Array<Node>} elements - Target DOM elements.\n * @return {array}                - The model & default attributes.\n */\nfunction extractModel(elements) {\n  var model = {},\n    defaults = {},\n    element,\n    defaultElement,\n    id;\n  for (var i = 0, l = elements.length; i < l; i++) {\n    element = elements[i];\n    id = element.getAttribute('id') || element.getAttribute('for');\n    model[id] = {\n      id: id,\n      type: element.getAttribute('type') || 'string',\n      title: !isReallyNaN(+id) ? element.getAttribute('title') || id : id\n    };\n\n    // Default?\n    defaultElement = element.getElementsByTagName('default')[0];\n    if (defaultElement) defaults[model[id].title] = cast(model[id].type, defaultElement.textContent);\n  }\n  return [model, defaults];\n}\n\n/**\n * Function used to collect an element's attributes.\n *\n * @param  {object} model    - Data model to use.\n * @param  {object} defaults - Default values.\n * @param  {Node}   element  - Target DOM element.\n * @return {object}          - The collected attributes.\n */\nfunction collectAttributes(model, defaults, element) {\n  var data = {},\n    label = element.getAttribute('label'),\n    weight = element.getAttribute('weight');\n  if (label) data.label = label;\n  if (weight) data.weight = +weight;\n  var valueElements = element.getElementsByTagName('attvalue'),\n    valueElement,\n    id;\n  for (var i = 0, l = valueElements.length; i < l; i++) {\n    valueElement = valueElements[i];\n    id = valueElement.getAttribute('id') || valueElement.getAttribute('for');\n    data[model[id].title] = cast(model[id].type, valueElement.getAttribute('value'));\n  }\n\n  // Applying default values\n  var k;\n  for (k in defaults) {\n    if (!(k in data)) data[k] = defaults[k];\n  }\n\n  // TODO: shortcut here to avoid viz when namespace is not set\n\n  // Attempting to find viz namespace tags\n\n  //-- 1) Color\n  var vizElement = getFirstMatchingVizTag(element, 'color');\n  if (vizElement) data.color = toRGBString(vizElement);\n\n  //-- 2) Size\n  vizElement = getFirstMatchingVizTag(element, 'size');\n  if (vizElement) data.size = +vizElement.getAttribute('value');\n\n  //-- 3) Position\n  var x, y, z;\n  vizElement = getFirstMatchingVizTag(element, 'position');\n  if (vizElement) {\n    x = vizElement.getAttribute('x');\n    y = vizElement.getAttribute('y');\n    z = vizElement.getAttribute('z');\n    if (x) data.x = +x;\n    if (y) data.y = +y;\n    if (z) data.z = +z;\n  }\n\n  //-- 4) Shape\n  vizElement = getFirstMatchingVizTag(element, 'shape');\n  if (vizElement) data.shape = vizElement.getAttribute('value');\n\n  //-- 5) Thickness\n  vizElement = getFirstMatchingVizTag(element, 'thickness');\n  if (vizElement) data.thickness = +vizElement.getAttribute('value');\n  return data;\n}\n\n/**\n * Factory taking implementations of `DOMParser` & `Document` returning\n * the parser function.\n */\nmodule.exports = function createParserFunction(DOMParser, Document) {\n  /**\n   * Function taking either a string or a document and returning a\n   * graphology instance.\n   *\n   * @param {function}        Graph  - A graphology constructor.\n   * @param {string|Document} source - The source to parse.\n   * @param {object}          options - Parsing options.\n   */\n\n  // TODO: option to map the data to the attributes for customization, nodeModel, edgeModel, nodeReducer, edgeReducer\n  // TODO: option to disable the model mapping heuristic\n  return function parse(Graph, source, options) {\n    options = options || {};\n    var addMissingNodes = options.addMissingNodes === true;\n    var mergeResult;\n    var xmlDoc = source;\n    var element, result, type, attributes, id, s, t, i, l;\n    if (!isGraphConstructor(Graph)) throw new Error('graphology-gexf/parser: invalid Graph constructor.');\n\n    // If source is a string, we are going to parse it\n    if (typeof source === 'string') xmlDoc = new DOMParser().parseFromString(source, 'application/xml');\n    if (!(xmlDoc instanceof Document)) throw new Error('graphology-gexf/parser: source should either be a XML document or a string.');\n\n    // Finding useful elements\n    var GRAPH_ELEMENT = xmlDoc.getElementsByTagName('graph')[0],\n      META_ELEMENT = xmlDoc.getElementsByTagName('meta')[0],\n      META_ELEMENTS = META_ELEMENT && META_ELEMENT.childNodes || [],\n      NODE_ELEMENTS = xmlDoc.getElementsByTagName('node'),\n      EDGE_ELEMENTS = xmlDoc.getElementsByTagName('edge'),\n      MODEL_ELEMENTS = xmlDoc.getElementsByTagName('attributes'),\n      NODE_MODEL_ELEMENTS = [],\n      EDGE_MODEL_ELEMENTS = [];\n    for (i = 0, l = MODEL_ELEMENTS.length; i < l; i++) {\n      element = MODEL_ELEMENTS[i];\n      if (element.getAttribute('class') === 'node') NODE_MODEL_ELEMENTS = element.getElementsByTagName('attribute');else if (element.getAttribute('class') === 'edge') EDGE_MODEL_ELEMENTS = element.getElementsByTagName('attribute');\n    }\n\n    // Information\n    var DEFAULT_EDGE_TYPE = GRAPH_ELEMENT.getAttribute('defaultedgetype') || 'undirected';\n    if (DEFAULT_EDGE_TYPE === 'mutual') DEFAULT_EDGE_TYPE = 'undirected';\n\n    // Computing models\n    result = extractModel(NODE_MODEL_ELEMENTS);\n    var NODE_MODEL = result[0],\n      NODE_DEFAULT_ATTRIBUTES = result[1];\n    result = extractModel(EDGE_MODEL_ELEMENTS);\n    var EDGE_MODEL = result[0],\n      EDGE_DEFAULT_ATTRIBUTES = result[1];\n\n    // Polling the first edge to guess the type of the edges\n    var graphType = EDGE_ELEMENTS[0] ? EDGE_ELEMENTS[0].getAttribute('type') || DEFAULT_EDGE_TYPE : 'mixed';\n\n    // Instantiating our graph\n    var graph = new Graph({\n      type: graphType\n    });\n\n    // Collecting meta\n    var meta = collectMeta(META_ELEMENTS),\n      lastModifiedDate = META_ELEMENT && META_ELEMENT.getAttribute('lastmodifieddate');\n    graph.replaceAttributes(meta);\n    if (lastModifiedDate) graph.setAttribute('lastModifiedDate', lastModifiedDate);\n\n    // Adding nodes\n    for (i = 0, l = NODE_ELEMENTS.length; i < l; i++) {\n      element = NODE_ELEMENTS[i];\n      graph.addNode(element.getAttribute('id'), collectAttributes(NODE_MODEL, NODE_DEFAULT_ATTRIBUTES, element));\n    }\n\n    // Adding edges\n    for (i = 0, l = EDGE_ELEMENTS.length; i < l; i++) {\n      element = EDGE_ELEMENTS[i];\n      id = element.getAttribute('id');\n      type = element.getAttribute('type') || DEFAULT_EDGE_TYPE;\n      s = element.getAttribute('source');\n      t = element.getAttribute('target');\n      attributes = collectAttributes(EDGE_MODEL, EDGE_DEFAULT_ATTRIBUTES, element);\n\n      // If we encountered an edge with a different type, we upgrade the graph\n      if (type !== graph.type && graph.type !== 'mixed') {\n        graph = toMixed(graph);\n      }\n\n      // If we encountered twice the same edge, we upgrade the graph\n      if (!graph.multi && (type === 'directed' && graph.hasDirectedEdge(s, t) || graph.hasUndirectedEdge(s, t))) {\n        graph = toMulti(graph);\n      }\n      mergeResult = mergeEdge(graph, type !== 'directed', id || null, s, t, attributes);\n      if (!addMissingNodes && (mergeResult[2] || mergeResult[3])) {\n        throw new Error('graphology-gexf/parser: one of your gexf file edges points to an inexisting node. Set the parser `addMissingNodes` option to `true` if you do not care.');\n      }\n    }\n    return graph;\n  };\n};","map":{"version":3,"names":["isGraphConstructor","require","mergeEdge","toMixed","toMulti","helpers","cast","isReallyNaN","value","toRGBString","element","a","getAttribute","r","g","b","getFirstMatchingVizTag","name","vizElement","getElementsByTagName","getElementsByTagNameNS","collectMeta","elements","meta","i","l","length","nodeName","textContent","trim","tagName","toLowerCase","extractModel","model","defaults","defaultElement","id","type","title","collectAttributes","data","label","weight","valueElements","valueElement","k","color","size","x","y","z","shape","thickness","module","exports","createParserFunction","DOMParser","Document","parse","Graph","source","options","addMissingNodes","mergeResult","xmlDoc","result","attributes","s","t","Error","parseFromString","GRAPH_ELEMENT","META_ELEMENT","META_ELEMENTS","childNodes","NODE_ELEMENTS","EDGE_ELEMENTS","MODEL_ELEMENTS","NODE_MODEL_ELEMENTS","EDGE_MODEL_ELEMENTS","DEFAULT_EDGE_TYPE","NODE_MODEL","NODE_DEFAULT_ATTRIBUTES","EDGE_MODEL","EDGE_DEFAULT_ATTRIBUTES","graphType","graph","lastModifiedDate","replaceAttributes","setAttribute","addNode","multi","hasDirectedEdge","hasUndirectedEdge"],"sources":["/Users/declanbradley/Documents/GitHub/house-finance/node_modules/graphology-gexf/common/parser.js"],"sourcesContent":["/* eslint no-self-compare: 0 */\n/**\n * Graphology Browser GEXF Parser\n * ===============================\n *\n * Browser version of the graphology GEXF parser using DOMParser to function.\n */\nvar isGraphConstructor = require('graphology-utils/is-graph-constructor');\nvar mergeEdge = require('graphology-utils/add-edge').mergeEdge;\nvar toMixed = require('graphology-operators/to-mixed');\nvar toMulti = require('graphology-operators/to-multi');\nvar helpers = require('../common/helpers.js');\n\nvar cast = helpers.cast;\n\n/**\n * Function checking whether the given value is a NaN.\n *\n * @param  {any} value - Value to test.\n * @return {boolean}\n */\nfunction isReallyNaN(value) {\n  return value !== value;\n}\n\n/**\n * Function used to convert a viz:color attribute into a CSS rgba? string.\n *\n * @param  {Node}   element - DOM element.\n * @return {string}\n */\nfunction toRGBString(element) {\n  var a = element.getAttribute('a'),\n    r = element.getAttribute('r'),\n    g = element.getAttribute('g'),\n    b = element.getAttribute('b');\n\n  return a\n    ? 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'\n    : 'rgb(' + r + ',' + g + ',' + b + ')';\n}\n\n/**\n * Function returning the first matching tag of the `viz` namespace matching\n * the desired tag name.\n *\n * @param  {Node}   element - Target DOM element.\n * @param  {string} name    - Tag name.\n * @return {Node}\n */\nfunction getFirstMatchingVizTag(element, name) {\n  var vizElement = element.getElementsByTagName('viz:' + name)[0];\n\n  if (!vizElement) vizElement = element.getElementsByTagNameNS('viz', name)[0];\n\n  if (!vizElement) vizElement = element.getElementsByTagName(name)[0];\n\n  return vizElement;\n}\n\n/**\n * Function used to collect meta information.\n *\n * @param  {Array<Node>} elements - Target DOM element.\n * @return {object}\n */\nfunction collectMeta(elements) {\n  var meta = {},\n    element,\n    value;\n\n  for (var i = 0, l = elements.length; i < l; i++) {\n    element = elements[i];\n\n    if (element.nodeName === '#text') continue;\n\n    value = element.textContent.trim();\n\n    if (value) meta[element.tagName.toLowerCase()] = element.textContent;\n  }\n\n  return meta;\n}\n\n/**\n * Function used to extract the model from the right elements.\n *\n * @param  {Array<Node>} elements - Target DOM elements.\n * @return {array}                - The model & default attributes.\n */\nfunction extractModel(elements) {\n  var model = {},\n    defaults = {},\n    element,\n    defaultElement,\n    id;\n\n  for (var i = 0, l = elements.length; i < l; i++) {\n    element = elements[i];\n    id = element.getAttribute('id') || element.getAttribute('for');\n\n    model[id] = {\n      id: id,\n      type: element.getAttribute('type') || 'string',\n      title: !isReallyNaN(+id) ? element.getAttribute('title') || id : id\n    };\n\n    // Default?\n    defaultElement = element.getElementsByTagName('default')[0];\n\n    if (defaultElement)\n      defaults[model[id].title] = cast(\n        model[id].type,\n        defaultElement.textContent\n      );\n  }\n\n  return [model, defaults];\n}\n\n/**\n * Function used to collect an element's attributes.\n *\n * @param  {object} model    - Data model to use.\n * @param  {object} defaults - Default values.\n * @param  {Node}   element  - Target DOM element.\n * @return {object}          - The collected attributes.\n */\nfunction collectAttributes(model, defaults, element) {\n  var data = {},\n    label = element.getAttribute('label'),\n    weight = element.getAttribute('weight');\n\n  if (label) data.label = label;\n\n  if (weight) data.weight = +weight;\n\n  var valueElements = element.getElementsByTagName('attvalue'),\n    valueElement,\n    id;\n\n  for (var i = 0, l = valueElements.length; i < l; i++) {\n    valueElement = valueElements[i];\n    id = valueElement.getAttribute('id') || valueElement.getAttribute('for');\n\n    data[model[id].title] = cast(\n      model[id].type,\n      valueElement.getAttribute('value')\n    );\n  }\n\n  // Applying default values\n  var k;\n\n  for (k in defaults) {\n    if (!(k in data)) data[k] = defaults[k];\n  }\n\n  // TODO: shortcut here to avoid viz when namespace is not set\n\n  // Attempting to find viz namespace tags\n\n  //-- 1) Color\n  var vizElement = getFirstMatchingVizTag(element, 'color');\n\n  if (vizElement) data.color = toRGBString(vizElement);\n\n  //-- 2) Size\n  vizElement = getFirstMatchingVizTag(element, 'size');\n\n  if (vizElement) data.size = +vizElement.getAttribute('value');\n\n  //-- 3) Position\n  var x, y, z;\n\n  vizElement = getFirstMatchingVizTag(element, 'position');\n\n  if (vizElement) {\n    x = vizElement.getAttribute('x');\n    y = vizElement.getAttribute('y');\n    z = vizElement.getAttribute('z');\n\n    if (x) data.x = +x;\n    if (y) data.y = +y;\n    if (z) data.z = +z;\n  }\n\n  //-- 4) Shape\n  vizElement = getFirstMatchingVizTag(element, 'shape');\n\n  if (vizElement) data.shape = vizElement.getAttribute('value');\n\n  //-- 5) Thickness\n  vizElement = getFirstMatchingVizTag(element, 'thickness');\n\n  if (vizElement) data.thickness = +vizElement.getAttribute('value');\n\n  return data;\n}\n\n/**\n * Factory taking implementations of `DOMParser` & `Document` returning\n * the parser function.\n */\nmodule.exports = function createParserFunction(DOMParser, Document) {\n  /**\n   * Function taking either a string or a document and returning a\n   * graphology instance.\n   *\n   * @param {function}        Graph  - A graphology constructor.\n   * @param {string|Document} source - The source to parse.\n   * @param {object}          options - Parsing options.\n   */\n\n  // TODO: option to map the data to the attributes for customization, nodeModel, edgeModel, nodeReducer, edgeReducer\n  // TODO: option to disable the model mapping heuristic\n  return function parse(Graph, source, options) {\n    options = options || {};\n\n    var addMissingNodes = options.addMissingNodes === true;\n    var mergeResult;\n\n    var xmlDoc = source;\n\n    var element, result, type, attributes, id, s, t, i, l;\n\n    if (!isGraphConstructor(Graph))\n      throw new Error('graphology-gexf/parser: invalid Graph constructor.');\n\n    // If source is a string, we are going to parse it\n    if (typeof source === 'string')\n      xmlDoc = new DOMParser().parseFromString(source, 'application/xml');\n\n    if (!(xmlDoc instanceof Document))\n      throw new Error(\n        'graphology-gexf/parser: source should either be a XML document or a string.'\n      );\n\n    // Finding useful elements\n    var GRAPH_ELEMENT = xmlDoc.getElementsByTagName('graph')[0],\n      META_ELEMENT = xmlDoc.getElementsByTagName('meta')[0],\n      META_ELEMENTS = (META_ELEMENT && META_ELEMENT.childNodes) || [],\n      NODE_ELEMENTS = xmlDoc.getElementsByTagName('node'),\n      EDGE_ELEMENTS = xmlDoc.getElementsByTagName('edge'),\n      MODEL_ELEMENTS = xmlDoc.getElementsByTagName('attributes'),\n      NODE_MODEL_ELEMENTS = [],\n      EDGE_MODEL_ELEMENTS = [];\n\n    for (i = 0, l = MODEL_ELEMENTS.length; i < l; i++) {\n      element = MODEL_ELEMENTS[i];\n\n      if (element.getAttribute('class') === 'node')\n        NODE_MODEL_ELEMENTS = element.getElementsByTagName('attribute');\n      else if (element.getAttribute('class') === 'edge')\n        EDGE_MODEL_ELEMENTS = element.getElementsByTagName('attribute');\n    }\n\n    // Information\n    var DEFAULT_EDGE_TYPE =\n      GRAPH_ELEMENT.getAttribute('defaultedgetype') || 'undirected';\n\n    if (DEFAULT_EDGE_TYPE === 'mutual') DEFAULT_EDGE_TYPE = 'undirected';\n\n    // Computing models\n    result = extractModel(NODE_MODEL_ELEMENTS);\n\n    var NODE_MODEL = result[0],\n      NODE_DEFAULT_ATTRIBUTES = result[1];\n\n    result = extractModel(EDGE_MODEL_ELEMENTS);\n\n    var EDGE_MODEL = result[0],\n      EDGE_DEFAULT_ATTRIBUTES = result[1];\n\n    // Polling the first edge to guess the type of the edges\n    var graphType = EDGE_ELEMENTS[0]\n      ? EDGE_ELEMENTS[0].getAttribute('type') || DEFAULT_EDGE_TYPE\n      : 'mixed';\n\n    // Instantiating our graph\n    var graph = new Graph({\n      type: graphType\n    });\n\n    // Collecting meta\n    var meta = collectMeta(META_ELEMENTS),\n      lastModifiedDate =\n        META_ELEMENT && META_ELEMENT.getAttribute('lastmodifieddate');\n\n    graph.replaceAttributes(meta);\n\n    if (lastModifiedDate)\n      graph.setAttribute('lastModifiedDate', lastModifiedDate);\n\n    // Adding nodes\n    for (i = 0, l = NODE_ELEMENTS.length; i < l; i++) {\n      element = NODE_ELEMENTS[i];\n\n      graph.addNode(\n        element.getAttribute('id'),\n        collectAttributes(NODE_MODEL, NODE_DEFAULT_ATTRIBUTES, element)\n      );\n    }\n\n    // Adding edges\n    for (i = 0, l = EDGE_ELEMENTS.length; i < l; i++) {\n      element = EDGE_ELEMENTS[i];\n\n      id = element.getAttribute('id');\n      type = element.getAttribute('type') || DEFAULT_EDGE_TYPE;\n      s = element.getAttribute('source');\n      t = element.getAttribute('target');\n      attributes = collectAttributes(\n        EDGE_MODEL,\n        EDGE_DEFAULT_ATTRIBUTES,\n        element\n      );\n\n      // If we encountered an edge with a different type, we upgrade the graph\n      if (type !== graph.type && graph.type !== 'mixed') {\n        graph = toMixed(graph);\n      }\n\n      // If we encountered twice the same edge, we upgrade the graph\n      if (\n        !graph.multi &&\n        ((type === 'directed' && graph.hasDirectedEdge(s, t)) ||\n          graph.hasUndirectedEdge(s, t))\n      ) {\n        graph = toMulti(graph);\n      }\n\n      mergeResult = mergeEdge(\n        graph,\n        type !== 'directed',\n        id || null,\n        s,\n        t,\n        attributes\n      );\n\n      if (!addMissingNodes && (mergeResult[2] || mergeResult[3])) {\n        throw new Error(\n          'graphology-gexf/parser: one of your gexf file edges points to an inexisting node. Set the parser `addMissingNodes` option to `true` if you do not care.'\n        );\n      }\n    }\n\n    return graph;\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}