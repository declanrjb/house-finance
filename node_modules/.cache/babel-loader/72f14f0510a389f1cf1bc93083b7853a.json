{"ast":null,"code":"/* eslint no-self-compare: 0 */\n/**\n * Graphology Common GEXF Writer\n * ==============================\n *\n * GEXF writer working for both node.js & the browser.\n */\nvar isGraph = require('graphology-utils/is-graph'),\n  inferType = require('graphology-utils/infer-type'),\n  XMLWriter = require('xml-writer'),\n  sanitizeTagName = require('./helpers.js').sanitizeTagName;\n\n// TODO: handle object in color, position with object for viz\n\n/**\n * Constants.\n */\nvar GEXF_NAMESPACE = 'http://www.gexf.net/1.2draft',\n  GEXF_VIZ_NAMESPACE = 'http:///www.gexf.net/1.1draft/viz';\nvar VIZ_RESERVED_NAMES = new Set(['color', 'size', 'x', 'y', 'z', 'shape', 'thickness']);\nvar RGBA_TEST = /^\\s*rgba?\\s*\\(/i,\n  RGBA_MATCH = /^\\s*rgba?\\s*\\(\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*(?:,\\s*([.0-9]*))?\\)\\s*$/;\n\n/**\n * Function used to transform a CSS color into a RGBA object.\n *\n * @param  {string} value - Target value.\n * @return {object}\n */\nfunction CSSColorToRGBA(value) {\n  if (!value || typeof value !== 'string') return {};\n  if (value[0] === '#') {\n    value = value.slice(1);\n    return value.length === 3 ? {\n      r: parseInt(value[0] + value[0], 16),\n      g: parseInt(value[1] + value[1], 16),\n      b: parseInt(value[2] + value[2], 16)\n    } : {\n      r: parseInt(value[0] + value[1], 16),\n      g: parseInt(value[2] + value[3], 16),\n      b: parseInt(value[4] + value[5], 16)\n    };\n  } else if (RGBA_TEST.test(value)) {\n    var result = {};\n    value = value.match(RGBA_MATCH);\n    result.r = +value[1];\n    result.g = +value[2];\n    result.b = +value[3];\n    if (value[4]) result.a = +value[4];\n    return result;\n  }\n  return {};\n}\n\n/**\n * Function used to map an element's attributes to a standardized map of\n * GEXF expected properties (label, viz, attributes).\n *\n * @param  {string} type       - The element's type.\n * @param  {string} key        - The element's key.\n * @param  {object} attributes - The element's attributes.\n * @return {object}\n */\nfunction DEFAULT_ELEMENT_FORMATTER(type, key, attributes) {\n  var output = {},\n    name;\n  for (name in attributes) {\n    if (name === 'label') {\n      output.label = attributes.label;\n    } else if (type === 'edge' && name === 'weight') {\n      output.weight = attributes.weight;\n    } else if (VIZ_RESERVED_NAMES.has(name)) {\n      output.viz = output.viz || {};\n      output.viz[name] = attributes[name];\n    } else {\n      output.attributes = output.attributes || {};\n      output.attributes[name] = attributes[name];\n    }\n  }\n  return output;\n}\nvar DEFAULT_NODE_FORMATTER = DEFAULT_ELEMENT_FORMATTER.bind(null, 'node'),\n  DEFAULT_EDGE_FORMATTER = DEFAULT_ELEMENT_FORMATTER.bind(null, 'edge');\n\n/**\n * Function used to check whether the given integer is 32 bits or not.\n *\n * @param  {number} number - Target number.\n * @return {boolean}\n */\nfunction is32BitInteger(number) {\n  return number <= 0x7fffffff && number >= -0x7fffffff;\n}\n\n/**\n * Function used to check whether the given value is \"empty\".\n *\n * @param  {any} value - Target value.\n * @return {boolean}\n */\nfunction isEmptyValue(value) {\n  return typeof value === 'undefined' || value === null || value === '' || value !== value;\n}\n\n/**\n * Function used to detect a JavaScript's value type in the GEXF model.\n *\n * @param  {any}    value - Target value.\n * @return {string}\n */\nfunction detectValueType(value) {\n  if (isEmptyValue(value)) return 'empty';\n  if (Array.isArray(value)) return 'liststring';\n  if (typeof value === 'boolean') return 'boolean';\n  if (typeof value === 'object') return 'string';\n\n  // Numbers\n  if (typeof value === 'number') {\n    // Integer\n    if (value === (value | 0)) {\n      // Long (JavaScript integer can go up to 53 bit)?\n      return is32BitInteger(value) ? 'integer' : 'long';\n    }\n\n    // JavaScript numbers are 64 bit float, hence the double\n    return 'double';\n  }\n  return 'string';\n}\n\n/**\n * Function used to cast the given value into the given type.\n *\n * @param  {string} type  - Target type.\n * @param  {any}    value - Value to cast.\n * @return {string}\n */\nfunction cast(type, value) {\n  if (type === 'liststring' && Array.isArray(value)) return value.join('|');\n  return '' + value;\n}\n\n/**\n * Function used to collect data from a graph's nodes.\n *\n * @param  {Graph}    graph   - Target graph.\n * @param  {function} format  - Function formatting the nodes attributes.\n * @return {array}\n */\nfunction collectNodeData(graph, format) {\n  var nodes = new Array(graph.order);\n  var i = 0;\n  graph.forEachNode(function (node, attr) {\n    var data = format(node, attr);\n    data.key = node;\n    nodes[i++] = data;\n  });\n  return nodes;\n}\n\n/**\n * Function used to collect data from a graph's edges.\n *\n * @param  {Graph}    graph   - Target graph.\n * @param  {function} reducer - Function reducing the edges attributes.\n * @return {array}\n */\nfunction collectEdgeData(graph, reducer) {\n  var edges = new Array(graph.size);\n  var i = 0;\n  graph.forEachEdge(function (edge, attr, source, target, _sa, _ta, undirected) {\n    var data = reducer(edge, attr);\n    data.key = edge;\n    data.source = source;\n    data.target = target;\n    data.undirected = undirected;\n    edges[i++] = data;\n  });\n  return edges;\n}\n\n/**\n * Function used to infer the model of the graph's nodes or edges.\n *\n * @param  {array} elements - The graph's relevant elements.\n * @return {array}\n */\n\n// TODO: on large graph, we could also sample or let the user indicate the types\nfunction inferModel(elements) {\n  var model = {},\n    attributes,\n    type,\n    k;\n\n  // Testing every attributes\n  for (var i = 0, l = elements.length; i < l; i++) {\n    attributes = elements[i].attributes;\n    if (!attributes) continue;\n    for (k in attributes) {\n      type = detectValueType(attributes[k]);\n      if (type === 'empty') continue;\n      if (!model[k]) model[k] = type;else {\n        if (model[k] === 'integer' && type === 'long') model[k] = type;else if (model[k] !== type) model[k] = 'string';\n      }\n    }\n  }\n\n  // TODO: check default values\n  return model;\n}\n\n/**\n * Function used to write a model.\n *\n * @param {XMLWriter} writer     - The writer to use.\n * @param {object}    model      - Model to write.\n * @param {string}    modelClass - Class of the model.\n */\nfunction writeModel(writer, model, modelClass) {\n  var name;\n  if (!Object.keys(model).length) return;\n  writer.startElement('attributes');\n  writer.writeAttribute('class', modelClass);\n  for (name in model) {\n    writer.startElement('attribute');\n    writer.writeAttribute('id', name);\n    writer.writeAttribute('title', name);\n    writer.writeAttribute('type', model[name]);\n    writer.endElement();\n  }\n  writer.endElement();\n}\nfunction writeElements(writer, type, model, elements) {\n  var emptyModel = !Object.keys(model).length,\n    element,\n    name,\n    color,\n    value,\n    edgeType,\n    attributes,\n    weight,\n    viz,\n    k,\n    i,\n    l;\n  writer.startElement(type + 's');\n  for (i = 0, l = elements.length; i < l; i++) {\n    element = elements[i];\n    attributes = element.attributes;\n    viz = element.viz;\n    writer.startElement(type);\n    writer.writeAttribute('id', element.key);\n    if (type === 'edge') {\n      edgeType = element.undirected ? 'undirected' : 'directed';\n      if (edgeType !== writer.defaultEdgeType) writer.writeAttribute('type', edgeType);\n      writer.writeAttribute('source', element.source);\n      writer.writeAttribute('target', element.target);\n      weight = element.weight;\n      if (typeof weight === 'number' && !isNaN(weight) || typeof weight === 'string') writer.writeAttribute('weight', element.weight);\n    }\n    if (element.label) writer.writeAttribute('label', element.label);\n    if (!emptyModel && attributes) {\n      writer.startElement('attvalues');\n      for (name in model) {\n        if (name in attributes) {\n          value = attributes[name];\n          if (isEmptyValue(value)) continue;\n          writer.startElement('attvalue');\n          writer.writeAttribute('for', name);\n          writer.writeAttribute('value', cast(model[name], value));\n          writer.endElement();\n        }\n      }\n      writer.endElement();\n    }\n    if (viz) {\n      //-- 1) Color\n      if (viz.color) {\n        color = CSSColorToRGBA(viz.color);\n        writer.startElementNS('viz', 'color');\n        for (k in color) {\n          writer.writeAttribute(k, color[k]);\n        }\n        writer.endElement();\n      }\n\n      //-- 2) Size\n      if ('size' in viz) {\n        writer.startElementNS('viz', 'size');\n        writer.writeAttribute('value', viz.size);\n        writer.endElement();\n      }\n\n      //-- 3) Position\n      if ('x' in viz || 'y' in viz || 'z' in viz) {\n        writer.startElementNS('viz', 'position');\n        if ('x' in viz) writer.writeAttribute('x', viz.x);\n        if ('y' in viz) writer.writeAttribute('y', viz.y);\n        if ('z' in viz) writer.writeAttribute('z', viz.z);\n        writer.endElement();\n      }\n\n      //-- 4) Shape\n      if (viz.shape) {\n        writer.startElementNS('viz', 'shape');\n        writer.writeAttribute('value', viz.shape);\n        writer.endElement();\n      }\n\n      //-- 5) Thickness\n      if ('thickness' in viz) {\n        writer.startElementNS('viz', 'thickness');\n        writer.writeAttribute('value', viz.thickness);\n        writer.endElement();\n      }\n    }\n    writer.endElement();\n  }\n  writer.endElement();\n}\n\n/**\n * Defaults.\n */\nvar DEFAULTS = {\n  encoding: 'UTF-8',\n  pretty: true,\n  formatNode: DEFAULT_NODE_FORMATTER,\n  formatEdge: DEFAULT_EDGE_FORMATTER\n};\n\n/**\n * Function taking a graphology instance & outputting a gexf string.\n *\n * @param  {Graph}  graph        - Target graphology instance.\n * @param  {object} options      - Options:\n * @param  {string}   [encoding]   - Character encoding.\n * @param  {boolean}  [pretty]     - Whether to pretty print output.\n * @param  {function} [formatNode] - Function formatting nodes' output.\n * @param  {function} [formatEdge] - Function formatting edges' output.\n * @return {string}              - GEXF string.\n */\nmodule.exports = function write(graph, options) {\n  if (!isGraph(graph)) throw new Error('graphology-gexf/writer: invalid graphology instance.');\n  options = options || {};\n  var indent = options.pretty === false ? false : '  ';\n  var formatNode = options.formatNode || DEFAULTS.formatNode,\n    formatEdge = options.formatEdge || DEFAULTS.formatEdge;\n  var writer = new XMLWriter(indent);\n  writer.startDocument('1.0', options.encoding || DEFAULTS.encoding);\n\n  // Starting gexf\n  writer.startElement('gexf');\n  writer.writeAttribute('version', '1.2');\n  writer.writeAttribute('xmlns', GEXF_NAMESPACE);\n  writer.writeAttribute('xmlns:viz', GEXF_VIZ_NAMESPACE);\n\n  // Processing meta\n  writer.startElement('meta');\n  var graphAttributes = graph.getAttributes();\n  if (graphAttributes.lastModifiedDate) writer.writeAttribute('lastmodifieddate', graphAttributes.lastModifiedDate);\n  var metaTagName;\n  var graphAttribute;\n  for (var k in graphAttributes) {\n    if (k === 'lastModifiedDate') continue;\n    metaTagName = sanitizeTagName(k);\n    if (!metaTagName) continue;\n    graphAttribute = graphAttributes[k];\n\n    // NOTE: if the graph attribute is not a scalar, we do not bother writing\n    // it as metadata in the gexf output. This means the writer/parser is not\n    // idempotent, but we cannot do better because the gexf format does not\n    // allow it, since it was not meant to handle complex values as graph\n    // metadata anyway.\n    if (typeof graphAttribute === 'string' || typeof graphAttribute === 'number' || typeof graphAttribute === 'boolean') {\n      writer.writeElement(metaTagName, '' + graphAttribute);\n    }\n  }\n  writer.endElement();\n  writer.startElement('graph');\n  var type = inferType(graph);\n  writer.defaultEdgeType = type === 'mixed' ? 'directed' : type;\n  writer.writeAttribute('defaultedgetype', writer.defaultEdgeType);\n\n  // Processing model\n  var nodes = collectNodeData(graph, formatNode),\n    edges = collectEdgeData(graph, formatEdge);\n  var nodeModel = inferModel(nodes);\n  writeModel(writer, nodeModel, 'node');\n  var edgeModel = inferModel(edges);\n  writeModel(writer, edgeModel, 'edge');\n\n  // Processing nodes\n  writeElements(writer, 'node', nodeModel, nodes);\n\n  // Processing edges\n  writeElements(writer, 'edge', edgeModel, edges);\n  return writer.toString();\n};","map":{"version":3,"names":["isGraph","require","inferType","XMLWriter","sanitizeTagName","GEXF_NAMESPACE","GEXF_VIZ_NAMESPACE","VIZ_RESERVED_NAMES","Set","RGBA_TEST","RGBA_MATCH","CSSColorToRGBA","value","slice","length","r","parseInt","g","b","test","result","match","a","DEFAULT_ELEMENT_FORMATTER","type","key","attributes","output","name","label","weight","has","viz","DEFAULT_NODE_FORMATTER","bind","DEFAULT_EDGE_FORMATTER","is32BitInteger","number","isEmptyValue","detectValueType","Array","isArray","cast","join","collectNodeData","graph","format","nodes","order","i","forEachNode","node","attr","data","collectEdgeData","reducer","edges","size","forEachEdge","edge","source","target","_sa","_ta","undirected","inferModel","elements","model","k","l","writeModel","writer","modelClass","Object","keys","startElement","writeAttribute","endElement","writeElements","emptyModel","element","color","edgeType","defaultEdgeType","isNaN","startElementNS","x","y","z","shape","thickness","DEFAULTS","encoding","pretty","formatNode","formatEdge","module","exports","write","options","Error","indent","startDocument","graphAttributes","getAttributes","lastModifiedDate","metaTagName","graphAttribute","writeElement","nodeModel","edgeModel","toString"],"sources":["/Users/declanbradley/Documents/GitHub/house-finance/node_modules/graphology-gexf/common/writer.js"],"sourcesContent":["/* eslint no-self-compare: 0 */\n/**\n * Graphology Common GEXF Writer\n * ==============================\n *\n * GEXF writer working for both node.js & the browser.\n */\nvar isGraph = require('graphology-utils/is-graph'),\n  inferType = require('graphology-utils/infer-type'),\n  XMLWriter = require('xml-writer'),\n  sanitizeTagName = require('./helpers.js').sanitizeTagName;\n\n// TODO: handle object in color, position with object for viz\n\n/**\n * Constants.\n */\nvar GEXF_NAMESPACE = 'http://www.gexf.net/1.2draft',\n  GEXF_VIZ_NAMESPACE = 'http:///www.gexf.net/1.1draft/viz';\n\nvar VIZ_RESERVED_NAMES = new Set([\n  'color',\n  'size',\n  'x',\n  'y',\n  'z',\n  'shape',\n  'thickness'\n]);\n\nvar RGBA_TEST = /^\\s*rgba?\\s*\\(/i,\n  RGBA_MATCH =\n    /^\\s*rgba?\\s*\\(\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*(?:,\\s*([.0-9]*))?\\)\\s*$/;\n\n/**\n * Function used to transform a CSS color into a RGBA object.\n *\n * @param  {string} value - Target value.\n * @return {object}\n */\nfunction CSSColorToRGBA(value) {\n  if (!value || typeof value !== 'string') return {};\n\n  if (value[0] === '#') {\n    value = value.slice(1);\n\n    return value.length === 3\n      ? {\n          r: parseInt(value[0] + value[0], 16),\n          g: parseInt(value[1] + value[1], 16),\n          b: parseInt(value[2] + value[2], 16)\n        }\n      : {\n          r: parseInt(value[0] + value[1], 16),\n          g: parseInt(value[2] + value[3], 16),\n          b: parseInt(value[4] + value[5], 16)\n        };\n  } else if (RGBA_TEST.test(value)) {\n    var result = {};\n\n    value = value.match(RGBA_MATCH);\n    result.r = +value[1];\n    result.g = +value[2];\n    result.b = +value[3];\n\n    if (value[4]) result.a = +value[4];\n\n    return result;\n  }\n\n  return {};\n}\n\n/**\n * Function used to map an element's attributes to a standardized map of\n * GEXF expected properties (label, viz, attributes).\n *\n * @param  {string} type       - The element's type.\n * @param  {string} key        - The element's key.\n * @param  {object} attributes - The element's attributes.\n * @return {object}\n */\nfunction DEFAULT_ELEMENT_FORMATTER(type, key, attributes) {\n  var output = {},\n    name;\n\n  for (name in attributes) {\n    if (name === 'label') {\n      output.label = attributes.label;\n    } else if (type === 'edge' && name === 'weight') {\n      output.weight = attributes.weight;\n    } else if (VIZ_RESERVED_NAMES.has(name)) {\n      output.viz = output.viz || {};\n      output.viz[name] = attributes[name];\n    } else {\n      output.attributes = output.attributes || {};\n      output.attributes[name] = attributes[name];\n    }\n  }\n\n  return output;\n}\n\nvar DEFAULT_NODE_FORMATTER = DEFAULT_ELEMENT_FORMATTER.bind(null, 'node'),\n  DEFAULT_EDGE_FORMATTER = DEFAULT_ELEMENT_FORMATTER.bind(null, 'edge');\n\n/**\n * Function used to check whether the given integer is 32 bits or not.\n *\n * @param  {number} number - Target number.\n * @return {boolean}\n */\nfunction is32BitInteger(number) {\n  return number <= 0x7fffffff && number >= -0x7fffffff;\n}\n\n/**\n * Function used to check whether the given value is \"empty\".\n *\n * @param  {any} value - Target value.\n * @return {boolean}\n */\nfunction isEmptyValue(value) {\n  return (\n    typeof value === 'undefined' ||\n    value === null ||\n    value === '' ||\n    value !== value\n  );\n}\n\n/**\n * Function used to detect a JavaScript's value type in the GEXF model.\n *\n * @param  {any}    value - Target value.\n * @return {string}\n */\nfunction detectValueType(value) {\n  if (isEmptyValue(value)) return 'empty';\n\n  if (Array.isArray(value)) return 'liststring';\n\n  if (typeof value === 'boolean') return 'boolean';\n\n  if (typeof value === 'object') return 'string';\n\n  // Numbers\n  if (typeof value === 'number') {\n    // Integer\n    if (value === (value | 0)) {\n      // Long (JavaScript integer can go up to 53 bit)?\n      return is32BitInteger(value) ? 'integer' : 'long';\n    }\n\n    // JavaScript numbers are 64 bit float, hence the double\n    return 'double';\n  }\n\n  return 'string';\n}\n\n/**\n * Function used to cast the given value into the given type.\n *\n * @param  {string} type  - Target type.\n * @param  {any}    value - Value to cast.\n * @return {string}\n */\nfunction cast(type, value) {\n  if (type === 'liststring' && Array.isArray(value)) return value.join('|');\n  return '' + value;\n}\n\n/**\n * Function used to collect data from a graph's nodes.\n *\n * @param  {Graph}    graph   - Target graph.\n * @param  {function} format  - Function formatting the nodes attributes.\n * @return {array}\n */\nfunction collectNodeData(graph, format) {\n  var nodes = new Array(graph.order);\n  var i = 0;\n\n  graph.forEachNode(function (node, attr) {\n    var data = format(node, attr);\n    data.key = node;\n    nodes[i++] = data;\n  });\n\n  return nodes;\n}\n\n/**\n * Function used to collect data from a graph's edges.\n *\n * @param  {Graph}    graph   - Target graph.\n * @param  {function} reducer - Function reducing the edges attributes.\n * @return {array}\n */\nfunction collectEdgeData(graph, reducer) {\n  var edges = new Array(graph.size);\n  var i = 0;\n\n  graph.forEachEdge(function (\n    edge,\n    attr,\n    source,\n    target,\n    _sa,\n    _ta,\n    undirected\n  ) {\n    var data = reducer(edge, attr);\n    data.key = edge;\n    data.source = source;\n    data.target = target;\n    data.undirected = undirected;\n    edges[i++] = data;\n  });\n\n  return edges;\n}\n\n/**\n * Function used to infer the model of the graph's nodes or edges.\n *\n * @param  {array} elements - The graph's relevant elements.\n * @return {array}\n */\n\n// TODO: on large graph, we could also sample or let the user indicate the types\nfunction inferModel(elements) {\n  var model = {},\n    attributes,\n    type,\n    k;\n\n  // Testing every attributes\n  for (var i = 0, l = elements.length; i < l; i++) {\n    attributes = elements[i].attributes;\n\n    if (!attributes) continue;\n\n    for (k in attributes) {\n      type = detectValueType(attributes[k]);\n\n      if (type === 'empty') continue;\n\n      if (!model[k]) model[k] = type;\n      else {\n        if (model[k] === 'integer' && type === 'long') model[k] = type;\n        else if (model[k] !== type) model[k] = 'string';\n      }\n    }\n  }\n\n  // TODO: check default values\n  return model;\n}\n\n/**\n * Function used to write a model.\n *\n * @param {XMLWriter} writer     - The writer to use.\n * @param {object}    model      - Model to write.\n * @param {string}    modelClass - Class of the model.\n */\nfunction writeModel(writer, model, modelClass) {\n  var name;\n\n  if (!Object.keys(model).length) return;\n\n  writer.startElement('attributes');\n  writer.writeAttribute('class', modelClass);\n\n  for (name in model) {\n    writer.startElement('attribute');\n    writer.writeAttribute('id', name);\n    writer.writeAttribute('title', name);\n    writer.writeAttribute('type', model[name]);\n    writer.endElement();\n  }\n\n  writer.endElement();\n}\n\nfunction writeElements(writer, type, model, elements) {\n  var emptyModel = !Object.keys(model).length,\n    element,\n    name,\n    color,\n    value,\n    edgeType,\n    attributes,\n    weight,\n    viz,\n    k,\n    i,\n    l;\n\n  writer.startElement(type + 's');\n\n  for (i = 0, l = elements.length; i < l; i++) {\n    element = elements[i];\n    attributes = element.attributes;\n    viz = element.viz;\n\n    writer.startElement(type);\n    writer.writeAttribute('id', element.key);\n\n    if (type === 'edge') {\n      edgeType = element.undirected ? 'undirected' : 'directed';\n\n      if (edgeType !== writer.defaultEdgeType)\n        writer.writeAttribute('type', edgeType);\n\n      writer.writeAttribute('source', element.source);\n      writer.writeAttribute('target', element.target);\n\n      weight = element.weight;\n\n      if (\n        (typeof weight === 'number' && !isNaN(weight)) ||\n        typeof weight === 'string'\n      )\n        writer.writeAttribute('weight', element.weight);\n    }\n\n    if (element.label) writer.writeAttribute('label', element.label);\n\n    if (!emptyModel && attributes) {\n      writer.startElement('attvalues');\n\n      for (name in model) {\n        if (name in attributes) {\n          value = attributes[name];\n\n          if (isEmptyValue(value)) continue;\n\n          writer.startElement('attvalue');\n          writer.writeAttribute('for', name);\n          writer.writeAttribute('value', cast(model[name], value));\n          writer.endElement();\n        }\n      }\n\n      writer.endElement();\n    }\n\n    if (viz) {\n      //-- 1) Color\n      if (viz.color) {\n        color = CSSColorToRGBA(viz.color);\n\n        writer.startElementNS('viz', 'color');\n\n        for (k in color) writer.writeAttribute(k, color[k]);\n\n        writer.endElement();\n      }\n\n      //-- 2) Size\n      if ('size' in viz) {\n        writer.startElementNS('viz', 'size');\n        writer.writeAttribute('value', viz.size);\n        writer.endElement();\n      }\n\n      //-- 3) Position\n      if ('x' in viz || 'y' in viz || 'z' in viz) {\n        writer.startElementNS('viz', 'position');\n\n        if ('x' in viz) writer.writeAttribute('x', viz.x);\n\n        if ('y' in viz) writer.writeAttribute('y', viz.y);\n\n        if ('z' in viz) writer.writeAttribute('z', viz.z);\n\n        writer.endElement();\n      }\n\n      //-- 4) Shape\n      if (viz.shape) {\n        writer.startElementNS('viz', 'shape');\n        writer.writeAttribute('value', viz.shape);\n        writer.endElement();\n      }\n\n      //-- 5) Thickness\n      if ('thickness' in viz) {\n        writer.startElementNS('viz', 'thickness');\n        writer.writeAttribute('value', viz.thickness);\n        writer.endElement();\n      }\n    }\n\n    writer.endElement();\n  }\n\n  writer.endElement();\n}\n\n/**\n * Defaults.\n */\nvar DEFAULTS = {\n  encoding: 'UTF-8',\n  pretty: true,\n  formatNode: DEFAULT_NODE_FORMATTER,\n  formatEdge: DEFAULT_EDGE_FORMATTER\n};\n\n/**\n * Function taking a graphology instance & outputting a gexf string.\n *\n * @param  {Graph}  graph        - Target graphology instance.\n * @param  {object} options      - Options:\n * @param  {string}   [encoding]   - Character encoding.\n * @param  {boolean}  [pretty]     - Whether to pretty print output.\n * @param  {function} [formatNode] - Function formatting nodes' output.\n * @param  {function} [formatEdge] - Function formatting edges' output.\n * @return {string}              - GEXF string.\n */\nmodule.exports = function write(graph, options) {\n  if (!isGraph(graph))\n    throw new Error('graphology-gexf/writer: invalid graphology instance.');\n\n  options = options || {};\n\n  var indent = options.pretty === false ? false : '  ';\n\n  var formatNode = options.formatNode || DEFAULTS.formatNode,\n    formatEdge = options.formatEdge || DEFAULTS.formatEdge;\n\n  var writer = new XMLWriter(indent);\n\n  writer.startDocument('1.0', options.encoding || DEFAULTS.encoding);\n\n  // Starting gexf\n  writer.startElement('gexf');\n  writer.writeAttribute('version', '1.2');\n  writer.writeAttribute('xmlns', GEXF_NAMESPACE);\n  writer.writeAttribute('xmlns:viz', GEXF_VIZ_NAMESPACE);\n\n  // Processing meta\n  writer.startElement('meta');\n  var graphAttributes = graph.getAttributes();\n\n  if (graphAttributes.lastModifiedDate)\n    writer.writeAttribute('lastmodifieddate', graphAttributes.lastModifiedDate);\n\n  var metaTagName;\n  var graphAttribute;\n\n  for (var k in graphAttributes) {\n    if (k === 'lastModifiedDate') continue;\n\n    metaTagName = sanitizeTagName(k);\n\n    if (!metaTagName) continue;\n\n    graphAttribute = graphAttributes[k];\n\n    // NOTE: if the graph attribute is not a scalar, we do not bother writing\n    // it as metadata in the gexf output. This means the writer/parser is not\n    // idempotent, but we cannot do better because the gexf format does not\n    // allow it, since it was not meant to handle complex values as graph\n    // metadata anyway.\n    if (\n      typeof graphAttribute === 'string' ||\n      typeof graphAttribute === 'number' ||\n      typeof graphAttribute === 'boolean'\n    ) {\n      writer.writeElement(metaTagName, '' + graphAttribute);\n    }\n  }\n\n  writer.endElement();\n  writer.startElement('graph');\n\n  var type = inferType(graph);\n\n  writer.defaultEdgeType = type === 'mixed' ? 'directed' : type;\n\n  writer.writeAttribute('defaultedgetype', writer.defaultEdgeType);\n\n  // Processing model\n  var nodes = collectNodeData(graph, formatNode),\n    edges = collectEdgeData(graph, formatEdge);\n\n  var nodeModel = inferModel(nodes);\n\n  writeModel(writer, nodeModel, 'node');\n\n  var edgeModel = inferModel(edges);\n\n  writeModel(writer, edgeModel, 'edge');\n\n  // Processing nodes\n  writeElements(writer, 'node', nodeModel, nodes);\n\n  // Processing edges\n  writeElements(writer, 'edge', edgeModel, edges);\n\n  return writer.toString();\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}